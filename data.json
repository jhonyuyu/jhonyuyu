{
    "success": true,
    "data": [
        {
            "id": "5a37c17dd92f2f5b185acfc4",
            "author_id": "4efc278525fa69ac6900000f",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><img src=\"https://dn-cnode.qbox.me/FuvPQvPz9RBxT07UrcBumIxmg-8G\" alt=\"1.png\"></p>\n<h2>大会简介</h2>\n<p>SEE = Seeking Experience &amp; Engineering，意为探索用户体验与工程实践，由蚂蚁金服集团每年举办 1-2 次，包括专业分享、产品展台、Workshop 等内容。希望通过 SEE Conf，能与业界同行一起分享交流体验科技的当前进展，一起探讨切磋体验科技的未来发展，共同努力促进体验设计与技术的开放，让生态繁荣共赢。</p>\n<p>首届 <a href=\"https://seeconf.alipay.com/\">SEE Conf</a> 将于 2018.01.06 在美丽的浙江杭州举办，届时我们将邀请数百位来自前端、设计、产品等领域的英才，围绕「极致用户体验」和「最佳工程实践」两大主题进行探讨交流。</p>\n<h2>特邀嘉宾</h2>\n<ul>\n<li>蚂蚁金服副总裁：胡喜 (阿玺)</li>\n<li>美团高级技术总监 ／ 业务负责人：刘平川 (rank)</li>\n<li>饿了么大前端部门负责人：林建锋 (sofish)</li>\n<li>百姓网资深前端架构师：贺师俊 (hax)</li>\n<li>豆瓣资深前端架构师：张克军 (kejun）</li>\n<li>钉钉资深技术专家：石玉磊 (佩玉)</li>\n<li>支付宝 UED 负责人：梁山鹰 (隼飞)</li>\n<li>蚂蚁金服体验技术部负责人：王保平 (玉伯)</li>\n</ul>\n<h2>会议日程</h2>\n<p>大会于 2018.01.06 正式召开，当天日程如下：</p>\n<ul>\n<li>09:00 - 09:15：开幕致辞</li>\n<li>09:15 - 10:00：蚂蚁中台设计体系 —— Ant Design 3.0 背后的故事</li>\n<li>10:00 - 10:45：Developer Experience First —— TWA 的理念与实践</li>\n<li>10:45 - 11:30：惊艳的互联网互动体验 —— AntG</li>\n<li>11:30 - 13:30：午间休息</li>\n<li>13:30 - 14:15：TECH 模型：企业级中后台产品体验度量探索</li>\n<li>14:15 - 15:00：AntV，返璞归真幻化万千可视化表达</li>\n<li>15:00 - 15:45：蚂蚁开发者工具，服务蚂蚁生态的移动研发 IDE</li>\n<li>15:45 - 16:30：轻推转型之门：Ant Design Pro 在企业级产品的探索</li>\n<li>16:30 - 16:45：从前端技术到体验科技，暨蚂蚁体验云起航</li>\n<li>16:45 - 17:15：圆桌 —— 体验科技的发展及未来</li>\n</ul>\n<h2>大会看点</h2>\n<p>这是蚂蚁金服体验科技首次对外发声，有大家熟悉的各个明星产品。有一个产品，过去 14 个月在 GitHub 的 star 数从 4k 飙升至 2w+，\n这是蚂蚁设计语言 <a href=\"https://ant.design/index-cn\">Ant Design</a>，她是在怎样的业务土壤与团队文化中成长起来的？背后有着怎样的故事？还有一个产品，刚一开源就得到世界级计算机科学家 <a href=\"https://www.cs.uic.edu/~wilkinson/\">Leland Wilkinson</a> 的肯定，这款技术产品是 <a href=\"https://github.com/antvis/g2\">G2</a>，其背后更大的蚂蚁可视化 <a href=\"https://antv.alipay.com/zh-cn/index.html\">AntV</a> 体系是本着怎样的初心在坚持前行？回顾过往，基于 Node.js 的前后端分层这几年在阿里经历了怎样的风雨？什么是 BFF（Backend For Frontend）架构？更进一步的 <strong>TWA</strong>（Techless Web App）架构是为了解决什么问题？为企业级框架和应用而生的 <a href=\"https://eggjs.org/\">Egg.js</a> 将走向何方？</p>\n<p>除此之外，还有最前沿的移动研发 IDE 技术和企业级产品体验度量的探索分享，更有未曾对外曝光，但已适配了千万机型的 Web 互动图形技术 AntG 将首度登台。从前端技术到体验科技，玉伯这位前端圈里的传奇黑侠将为我们讲述的“<strong>蚂蚁体验云</strong>”究竟是什么。</p>\n<p><img src=\"https://gw.alipayobjects.com/zos/rmsportal/ODVJIUEvmuKCwXqqJPfo.jpg\" alt></p>\n<p>技术大会不光能听到干货，还能面基好友结交各路大神。除了议程提到的众多明星嘉宾，从目前报名中已经发现数十位重量级人物，不乏知名公司的产品、设计总监，架构师，新锐公司的 CXO 和领域新秀。</p>\n<p>另外，蚂蚁金服是个藏龙卧虎的地方，有知名博主，也有知乎网红，有 Node.js、Ruby 等各个技术社区的大拿，还有仙剑主程、艺术插画大师，图形图像、数据可视化专家也会出没会场，有的还当起了会场志愿者在门口热切地期待着你的到来。他们会游走在会场与各个展台之间，也许就坐在你身边，这是面基好友结交大神的好时候，机会难得。</p>\n<p><img src=\"https://gw.alipayobjects.com/zos/rmsportal/DdjWkCAawyOMhFnLpGLK.jpg\" alt></p>\n<h2>如何报名</h2>\n<p>访问 <a href=\"https://seeconf.alipay.com/\">SEE Conf · 蚂蚁金服体验科技大会</a>，点击「立即报名」按钮</p>\n<p>支付宝扫描下方二维码</p>\n<p><img src=\"https://gw.alipayobjects.com/zos/rmsportal/gmcvvumwUehXYbTPBPno.gif\" alt></p>\n</div>",
            "title": "首届蚂蚁金服体验科技大会",
            "last_reply_at": "2017-12-21T00:56:10.319Z",
            "good": false,
            "top": true,
            "reply_count": 20,
            "visit_count": 1399,
            "create_at": "2017-12-18T13:24:13.334Z",
            "author": {
                "loginname": "fengmk2",
                "avatar_url": "https://avatars0.githubusercontent.com/u/156269?v=4&s=120"
            }
        },
        {
            "id": "5a2403226190c8912ebaceeb",
            "author_id": "4f447c2f0a8abae26e01b27d",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FhSNYCv6Ab9wzT6aUSfKLa0GtP4w\" alt=\"image.png\"></p>\n<blockquote>\n<p>原文地址：知乎专栏 <a href=\"https://zhuanlan.zhihu.com/p/31640541\">https://zhuanlan.zhihu.com/p/31640541</a></p>\n</blockquote>\n<p>给大家介绍下，Egg 2.0 正式版，今天 12.3 冒泡啦，距 3.21 的 <a href=\"https://zhuanlan.zhihu.com/p/25860846\">Egg 1.0 版本</a> 时隔 8 个月。</p>\n<p><img src=\"//dn-cnode.qbox.me/FrC_ZbrhyLkhVIquPOsMqPhvqsHX\" alt=\"image.png\"></p>\n<blockquote>\n<p><a href=\"https://eggjs.org/\">Egg</a> 是阿里 Node.js 的核心基础框架，面向『企业级的 Web 基础框架』这个领域，提供了「微内核 + 插件机制 + 框架定制能力」，完美达成生态共建和差异化定制的平衡点。<br>\n既适合个人小项目快速开发，也适合团队架构师基于自身的技术架构在 Egg 基础上扩展出适合特定团队业务场景的框架。<br>\n它沉淀自阿里在各行各业不同领域的大规模工程实践经验，稳定支撑了多年天猫双11大促，顶级流量压力。</p>\n</blockquote>\n<h2>2.0 特性</h2>\n<ul>\n<li>基于 Koa 2.x\n<ul>\n<li>异步解决方案直接基于 Async Function 。</li>\n<li>去除 co 兼容后<a href=\"https://github.com/eggjs/egg/wiki/co-vs-async\">堆栈信息更清晰</a>。</li>\n</ul>\n</li>\n<li>框架层优化带来 <a href=\"https://eggjs.github.io/benchmark/plot/\">30% 左右的性能提升</a>，不含 Node 8 带来的提升。</li>\n<li>为了方便开发者快速升级，保持了对 Egg 1.x 以及 generator function 的兼容。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fuf5DkXMxM7wfClcN6B6LzX5d18Q\" alt=\"image.png\"></p>\n<h2>如何升级</h2>\n<p><strong><a href=\"https://eggjs.org/\">Egg</a> 的理念之一是渐进式增强，故我们为开发者提供渐进升级的体验。</strong></p>\n<ol>\n<li>Node.js 使用最新的 LTS 版本（&gt;=8.9.0）。</li>\n<li>修改 package.json 中 egg 的依赖为 ^2.0.0。</li>\n<li>检查相关插件是否发布新版本（可选）。</li>\n<li>重新安装依赖，跑单元测试。</li>\n</ol>\n<p><strong>搞定！几乎不需要修改任何一行代码，就已经完成了升级。</strong></p>\n<p>这得益于 Egg 对 1.x 的兼容，但为了更好的统一代码风格，以及更佳的性能和错误堆栈，我们建议开发者参考 <a href=\"https://eggjs.org/zh-cn/migration.html\">升级指南</a> 进一步升级。</p>\n<h2>未来规划</h2>\n<p>如您所知，Egg 采用的是 <strong>『微内核 + 插件 + 上层框架』</strong> 模式。</p>\n<p>其中微内核经过 3 年 4 个版本，以及在阿里的大规模应用，已经打磨的非常稳定。</p>\n<p>接下来我们的<strong>重心主要在开发者体验方面的优化</strong>，包括：</p>\n<ul>\n<li>更好的开发者体验，包括 TypeScript，开发者工具，IDE 工具等方面。</li>\n<li>社区扶持\n<ul>\n<li>协助业界的前端团队，打造适合特定团队业务场景的上层框架，欢迎勾搭。</li>\n<li>分享我们在团队、协作、规范化等方面的经验。</li>\n<li>分享在 Docker，GraphQL，SSR 等方面的探索和最佳实践分享。</li>\n</ul>\n</li>\n<li>国际化，官网和<a href=\"https://github.com/eggjs/egg/issues/363\">文档翻译</a>等。</li>\n</ul>\n<p>同时，我们也欢迎社区更多的<a href=\"https://github.com/orgs/eggjs/projects\">参与</a>，一起打造更完善的生态。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fg_WHGNC13j2azgEWb-ONk5whle5\" alt=\"image.png\"></p>\n<h2>我们这一年</h2>\n<p>截止至今天(2017-12-03)：</p>\n<ul>\n<li><strong>GitHub 5.6k star</strong>，555 forks，npm 月下载量 11,140 (不含阿里内网数据)。</li>\n<li>从 1.0 到 2.0，我们一共发布了 <a href=\"https://github.com/eggjs/egg/releases\">18 个版本</a>，处理了 820 个 issue，收到了 500+ (主库 272) 个 Pull Request 。</li>\n<li>开发者体验方面的优化包括：<a href=\"https://eggjs.org/zh-cn/core/development.html#%E4%BD%BF%E7%94%A8-egg-bin-%E8%B0%83%E8%AF%95\">断点调试代理</a>，<a href=\"https://eggjs.org/zh-cn/core/development.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">单元测试+覆盖率</a>，<a href=\"https://eggjs.org/zh-cn/core/deployment.html#%E9%83%A8%E7%BD%B2\">部署工具</a>，TypeScript 支持，<a href=\"https://github.com/eggjs/vscode-eggjs\">VSCode 插件</a>，文档优化等等。</li>\n</ul>\n<p><strong>社区方面：</strong></p>\n<ul>\n<li>来自 BAT，丁香园，全民直播等多家兄弟公司的反馈和插件回馈。</li>\n<li>来自 <a href=\"https://github.com/eggjs/egg/network/dependents\">GitHub Dependents</a> 的统计：992 Repositories, 231 Packages</li>\n<li><a href=\"https://npms.io/search?q=egg-\">NPM 搜索结果</a>超过 400 个。</li>\n<li>上层框架：\n<ul>\n<li><a href=\"https://github.com/alibaba/beidou\">北斗</a> - Isomorphic framework for server-rendered React apps</li>\n<li><a href=\"https://github.com/avetjs/avet\">avet</a> - A very comfortable framework for writing isomorphic applications</li>\n</ul>\n</li>\n<li>如果你有好的分享，PR 传送门：<a href=\"https://github.com/eggjs/awesome-egg\">awesome-egg</a></li>\n</ul>\n<p><strong>趣味数据：</strong></p>\n<ul>\n<li>官网访问量中，Mac 占 47% → 这比例挺高的，看来 Node 程序猿都很幸福。</li>\n<li>周末的访问量约为平时的 1/3 → 看来 Node 程序猿周末加班少。（滑稽</li>\n<li>官网访问来源：站内，直链，外链各 30% 多，来自搜索引擎的较少。</li>\n</ul>\n<p><strong>分享交流：</strong></p>\n<ul>\n<li>在 <a href=\"http://2017.jsdc.tw/\">台灣 JSDC2017 開發者年會</a> 和 <a href=\"http://2017.imweb.io/index.html#schedule\">腾讯IMWebConf</a> 分享了『<a href=\"https://github.com/atian25/blog/raw/master/assets/files/Egg%20%26%20Node.js%20%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%9D%8A%E8%B5%B0%E5%90%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91.pdf\">Egg &amp; Node.js 从小工坊走向企业级开发</a>』</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/FgFUrGpNw07LKQPYzGgZp64j7CZH\" alt=\"image.png\"></p>\n<ul>\n<li>Node TSC @张秋怡 在 <a href=\"https://nina17.sched.com/event/Atii/nodejs-at-alibaba-a-joyee-cheung-alibaba-cloud\">Node Interactive North America 2017</a> 和 <a href=\"http://nodefest.jp/2017/schedule.html#joyee\">東京Node学園祭2017</a> 分享了『<a href=\"https://github.com/joyeecheung/talks/blob/master/node_fest_2017/nodejs_at_alibaba_tokyo.pdf\">Node.js at Alibaba</a>』。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fl5IyrfAMzQ49Uz3eQ67i2FLL09H\" alt=\"image.png\"></p>\n<ul>\n<li><a href=\"/user/ngot\">@ngot</a> 在 <a href=\"https://www.bagevent.com/event/751307\">Node Party</a> 分享了『<a href=\"https://github.com/Hangzhou-Node-Party/Node-Party/blob/master/2017-08-19/Egg.js%E5%9C%A8%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9B%86%E5%9B%A2%E7%9A%84%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%BF%90%E7%94%A8.pdf\">Egg.js 在阿里巴巴集团的实践运用</a>』</li>\n<li>@姜天意 在 <a href=\"http://2017.imweb.io/index.html#schedule\">腾讯IMWebConf</a> 分享了 『<a href=\"https://github.com/jtyjty99999/share/blob/master/security%20risk%20in%20node%20web.pdf\">脆弱的 Node.js</a>』</li>\n</ul>\n<h2>写在最后</h2>\n<p>开源，痛并快乐着。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fiamh5LNYR3e2E0HtdhrO3sVfHrs\" alt=\"image.png\"></p>\n</div>",
            "title": "企业级 Node.js 框架 Egg 发布 2.0，性能提升 30%，拥抱 Async",
            "last_reply_at": "2017-12-20T13:03:43.327Z",
            "good": true,
            "top": true,
            "reply_count": 54,
            "visit_count": 5639,
            "create_at": "2017-12-03T13:58:58.901Z",
            "author": {
                "loginname": "atian25",
                "avatar_url": "https://avatars1.githubusercontent.com/u/227713?v=3&s=120"
            }
        },
        {
            "id": "58eee565a92d341e48cfe7fc",
            "author_id": "54009f5ccd66f2eb37190485",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h1>2017，我们来聊聊 Node.js</h1>\n<h2>版本帝？</h2>\n<p>Chrome浏览器已经蹦到57版本了，是名副其实的版本帝，作为兄弟的Node.js也一样，1.0之前等了6年，而从1.0到8.0，只用了2年时间，这世界到底怎么了？</p>\n<p>我们就数一下</p>\n<ul>\n<li>从v0.1到0.12用了6年</li>\n<li>2015-01-14发布了v1.0.0版本（io.js）</li>\n<li>2.x（io.js）</li>\n<li>3.x（io.js）</li>\n<li>2015年09月Node.js基金会已发布Node.js V4.0版 与io.js合并后的第一个版本</li>\n<li>2015年10月Node.jsv4.2.0将是首个lts长期支持版本</li>\n<li>2016年底发布到4.2.4 &amp;&amp; 5.4.0</li>\n<li>2016年3月20日v4.4.0 LTS（长期支持版本）和v5.9.0 Stable（稳定版本）</li>\n<li>2016 年底 v6.0 支持95%以上的es6特性 ， v7.0通过flag支持async函数，99%的es6特性</li>\n<li>2017年2月发布v7.6版本，可以不通过flag使用async函数</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fv8fvViUeOJpBlOWYzBo1txRUhdN\" alt=\"lts-schedule.png\"></p>\n<p>整体来说趋于稳定</p>\n<ul>\n<li>成立了Node.js基金会，能够让Node.js在未来有更好的开源社区支持</li>\n<li>发布了LTS版本，意味着api稳定</li>\n<li>快速发版本，很多人吐槽这个，其实换个角度看，这也是社区活跃的一个体现，但如果大家真的看CHANGELOG，其实都是小改进，而且是边边角角的改进，也就是说Node.js的core（核心）已经非常稳定了，可以大规模使用</li>\n</ul>\n<h2>已无性能优势？</h2>\n<p>Node.js在2009年横空出世，可以说是纯异步获得高性能的功劳。所有语言几乎没有能够和它相比的，比如Java、PHP、Ruby都被啪啪的打脸。但是山一程，水一程，福祸相依，因为性能太出众，导致很多语言、编程模型上有更多探索，比如go语言产生、php里的swolo和vm改进等，大家似乎都以不支持异步为耻辱。后来的故事大家都知道了，性能都提到非常高，c10问题已经没人再考虑，只是大家实现早晚而产生的性能差距而已。</p>\n<blockquote>\n<p>编程语言的性能趋于一样的极限，所以剩下的选择，只有喜好</p>\n</blockquote>\n<p>那么在这种情况下，Node.js还有优势么？</p>\n<ul>\n<li>实现成本：Node.js除了异步流程控制稍复杂外，其他的都非常简单，比如写法，你可以面向过程、面向对象、函数式，根据自己的解决选择就好了。不要因为它现在变化快，就觉得自己跟不上潮流。尤其是后端程序员转Node.js几乎是2周以内的成本，某些语言光熟悉语法习惯也不止2周吧？</li>\n<li>调优成本：Node.js即使不优化，它的性能也非常好，如果优化，也比其他语言更简单</li>\n<li>学习成本：是否必须用，如果是必须要用，那就少学一样是一样，人生有限，不能都花在写hello world上。我想问，大前端离得开js么？</li>\n</ul>\n<blockquote>\n<p>误读：Node.js已无性能优势，它现在最强大的是基于npm的生态</p>\n</blockquote>\n<p>上面是成本上的比较，其实大家把关注点都转移到基于npm的生态上，截止2017年2月，在npm上有超过45万个模块，秒杀无数。npm是所有的开源的包管理里最强大的，我们说更了不起的Node.js，其实npm居功甚伟，后面会有独立的章节进行阐述。</p>\n<p>来自<a href=\"http://www.modulecounts.com/\">www.modulecounts.com</a>的各个包管理模块梳理的比较</p>\n<p><img src=\"//dn-cnode.qbox.me/FjmazMxffKETUdl9-NVoSqLB-DyT\" alt=\"Screen Shot 2017-04-04 at 21.02.41.png\">\nnpm生态是Node的优势不假，可是说“Node.js没有性能优势”真的对么？这其实就是误读，Node.js的性能依然很好呀，而且它有npm极其强大的生态，可谓性能与生态双剑合璧，你说你死不死？</p>\n<h2>异步和回调地狱？</h2>\n<blockquote>\n<p>天生异步，败也异步，成也异步</p>\n</blockquote>\n<p>正因为异步导致了api设计方式只能采用error-first风格的回调，于是大家硬生生的把callback写成了callback hell。于是各种黑粉就冒出来，无非是一些浅尝辄止之辈。但也正因为回调地狱是最差实践，所以大家才不得不求变，于是thunk、promise等纷沓而至。虽然Promise/A+不完美，但对于解决回调地狱是足够的了。而且随着ES6等规范实现，引入generator、co等，让异步越来越近于同步。当async函数落地的时候，Node已经站在了同C#、Python一样的高度上，大家还有什么理由黑呢？</p>\n<p>本小节先科普一下异步流程里的各种概念，后面会有独立章节进行详细讲解</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>callback</td>\n<td>Node.js API天生就是这样的</td>\n<td></td>\n</tr>\n<tr>\n<td>thunk</td>\n<td>参数的求值策略</td>\n<td></td>\n</tr>\n<tr>\n<td>promise</td>\n<td>最开始是Promise/A+规范，随后成为ES6标准</td>\n<td></td>\n</tr>\n<tr>\n<td>generator</td>\n<td>ES6种的生成器，用于计算，但tj想用做流程控制</td>\n<td></td>\n</tr>\n<tr>\n<td>co</td>\n<td>generator用起来非常麻烦，故而tj写了co这个generator生成器，用法更简单</td>\n<td></td>\n</tr>\n<tr>\n<td>async函数</td>\n<td>原本计划进入es7规范，结果差一点，但好在v8实现了，所以node 7就可以使用，无须等es7规范落地</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>有时，将一件事儿做到极致，也许能有另一种天地</p>\n</blockquote>\n<h2>应用场景</h2>\n<p>MEAN是一个Javascript平台的现代Web开发框架总称，它是MongoDB + Express +AngularJS + NodeJS 四个框架的第一个字母组合。它与传统LAMP一样是一种全套开发工具的简称。在2014和2015年喜欢讲这个，并且还有MEAN.js等框架，但今天已经过时，Node.js有了更多的应用场景。</p>\n<p>《Node.js in action》一书里说，Node所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为Node自身在I/O上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。</p>\n<p>这话不假，但在今天来看，DIRT还是范围小了。其实DIRT本质上说的I/O处理的都算，但随着大前端的发展，Node.js已经不再只是I/O处理相关，而是更加的“Node”！</p>\n<p>这里给出Node.js的若干使用场景</p>\n<ul>\n<li>网站（如express/koa等）</li>\n<li>im即时聊天(<a href=\"http://socket.io\">socket.io</a>)</li>\n<li>api（移动端，pc，h5）</li>\n<li>HTTP Proxy（淘宝、Qunar、腾讯、百度都有）</li>\n<li>前端构建工具(grunt/gulp/bower/webpack/fis3…)</li>\n<li>写操作系统（NodeOS）</li>\n<li>跨平台打包工具（PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的cordova，即老的Phonegap，还有更加有名的一站式开发框架ionicframework）</li>\n<li>命令行工具（比如cordova、shell.js）</li>\n<li>反向代理（比如anyproxy，node-http-proxy）</li>\n<li>编辑器Atom、VSCode等</li>\n</ul>\n<p>可以说目前大家能够看到的、用到的软件都有Node.js身影，当下最流行的软件写法也大都是基于Node.js的，比如PC客户端<a href=\"https://github.com/luin/medis\">luin/medis</a>采用electron打包，写法采用React+Redux。我自己一直的实践的【Node全栈】，也正是基于这种趋势而形成的。在未来，Node.js的应用场景会更加的广泛。更多参见<a href=\"https://github.com/sindresorhus/awesome-nodejs\">sindresorhus/awesome-nodejs</a>。</p>\n<h3>Web框架</h3>\n<p>演进时间线大致如下：</p>\n<ul>\n<li>2010年tj写的Express</li>\n<li>2011年Derby.js开始开发，8月5日，WalmartLabs的一位成员Eran Hammer提交了Hapi的第一次commit。Hapi原本是Postmile的一部分，并且最开始是基于Express构建的。后来它发展成自己自己的框架，</li>\n<li>2012年1月21日，专注于rest api的restify发布1.0版本，同构的meteor开始投入开发，最像rails的sails也开始了开发</li>\n<li>2013年tj开始玩generator，编写co这个generator执行器，并开始了Koa。2013 年下半年李成银开始ThinkJS，参考ThinkPHP</li>\n<li>2014年，4月9日，express发布4.0，进入4.x时代持续到今天，MEAN.js开始随着MEAN架构的提出开始开发，意图大一统，另外total.js开始，最像PHP’s Laravel 或 Python’s Django 或 <a href=\"http://ASP.NET\">ASP.NET</a> MVC的框架</li>\n<li>2015年8月22日， 下一代Web框架Koa发布1.0，可以在node 0.12下面，通过co + generator实现同步逻辑，那时候co还是基于thunkfy的，2015.10.30 ThinkJS发布了Es2015+ 特性开发的v 2.0版本</li>\n<li>2016 年 09 月，蚂蚁金服的eggjs，在 JSConf China 2016 上亮相并宣布开源</li>\n<li>2017年2月，下一代Web框架Koa发布2.0</li>\n</ul>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是Node.js成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n</tbody>\n</table>\n<p>对于框架选型</p>\n<ul>\n<li>业务场景、特点，不必为了什么而什么，避免本末倒置</li>\n<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定</li>\n<li>出现问题的时候，有人能Cover的住，Node.js虽然8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度</li>\n</ul>\n<blockquote>\n<p>个人学习求新，企业架构求稳，无非喜好与场景而已</p>\n</blockquote>\n<p>我猜大家能够想到的场景，大约如下</p>\n<ul>\n<li>前端工具，比如gulp、grunt、webpack等</li>\n<li>服务器，做类似于Java、PHP的事儿</li>\n</ul>\n<p>如果只是做这些，和Java、PHP等就没啥区别了。如果再冠上更了不起的Node.js，就有点名不符实了。所以这里我稍加整理，看看和大家想的是否一样</p>\n<h3>技术栈演进</h3>\n<p>自从ES 2015（俗称ES 6）在Node.js 落地之后，整个Node.js开发都发生了翻天覆地的变化。自从0.10开始，Node.js就逐渐的加入了ES 6特性，比如0.12就可以使用generator，才导致寻求异步流程控制的tj写出了co这个著名的模块，继而诞生了Koa框架。但是在4.0之前，一直都是要通过flag才能开启generator支持，故而Koa 1.0迟迟未发布，在Node 4.0发布才发布的Koa 1.0。</p>\n<blockquote>\n<p>2015年，成熟的传统，而2016年，变革开始</p>\n</blockquote>\n<p>核心变更：es语法支持</p>\n<ul>\n<li>使用Node.js 4.x或5.x里的es6特性，如果想玩更高级的，可以使用<a href>babel</a>编译支持es7特性，或者typescript</li>\n<li>合理使用<a href=\"https://github.com/feross/standard\">standard</a>  或者 xo 代码风格约定</li>\n<li>适当的引入ES 6语法，只要Node.js SDK支持的，都可以使用</li>\n<li>需要大家重视OO（面向对象）写法的学习和使用，虽然ES 6的OO机制不健全，但这是大方向，以后会一直增强。OO对于大型软件开发更好。这其实也是我看好typescript的原因。</li>\n</ul>\n<p>对比一下变革前后的技术栈选型，希望读者能够从中感受到其中的变化</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>2015年</th>\n<th>2016年</th>\n<th>选型原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web框架</td>\n<td>express 4.x</td>\n<td>koa 1.0 &amp;&amp; 2.0 （koa2.0刚发布不久，喜欢折腾的可以考虑）</td>\n<td>主要在流程控制上的便利，异步毕竟要时刻注意，心累</td>\n</tr>\n<tr>\n<td>数据库</td>\n<td>mongoose（mongodb）</td>\n<td>mongoose（mongodb）</td>\n<td>对mongodb和mysql支持都一样，不过是mongodb更简单，足以应付绝大部分场景</td>\n</tr>\n<tr>\n<td>异步流程控制</td>\n<td>bluebird（Promise/A+实现）</td>\n<td>bluebird（Promise/A+实现）1） Koa 1.0 使用co + generator 2） Koa 2.0 使用async函数</td>\n<td>流程控制演进路线，从promise到async函数，无论如何，promise都是基石，必要掌握的</td>\n</tr>\n<tr>\n<td>模板引擎（视图层）</td>\n<td>ejs &amp;&amp; jade</td>\n<td>jade &amp;&amp; nunjucks</td>\n<td>给出了2种，一种可读性好，另一种简洁高效，都是非常好的</td>\n</tr>\n<tr>\n<td>测试</td>\n<td>mocha</td>\n<td>ava</td>\n<td>mocha是Node.js里著名的测试框架，但对新特性的支持没有ava那么好，而ava基于babel安装也要大上好多</td>\n</tr>\n<tr>\n<td>调试</td>\n<td>node-inspector</td>\n<td>VSCode</td>\n<td>在Node 6和7出来之后，node-inspector支持的不是那么好，相反VSCode可视化，简单，文件多时也不卡，特别好用</td>\n</tr>\n</tbody>\n</table>\n<h3>预处理器</h3>\n<p>前端预处理可分3种</p>\n<ul>\n<li>模板引擎</li>\n<li>css预处理器</li>\n<li>js友好语言</li>\n</ul>\n<p>这些都离不开Node.js的支持，对于前端工程师来说，使用Node.js来实现这些是最方便不过的。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>实现</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模板引擎</td>\n<td>art\\mustache\\ejs\\hbs\\jade …</td>\n<td>上百种之多，自定义默认，编译成html，继而完成更多操作</td>\n</tr>\n<tr>\n<td>css预处理器</td>\n<td>less\\sass\\scss\\rework\\postcss</td>\n<td>自定义语法规则，编译成css</td>\n</tr>\n<tr>\n<td>js友好语言</td>\n<td>coffeescript、typescript</td>\n<td>自定义语法规则、编译成js</td>\n</tr>\n</tbody>\n</table>\n<h3>跨平台</h3>\n<p>跨平台指的是PC端、移动端、Web/H5</p>\n<table>\n<thead>\n<tr>\n<th>平台</th>\n<th>实现</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web/H5</td>\n<td>纯前端</td>\n<td>不必解释</td>\n</tr>\n<tr>\n<td>PC客户端</td>\n<td>nw.js和electron</td>\n<td>尤其是atom和vscode编辑器最为著名，像钉钉PC端，微信客户端、微信小程序IDE等都是这样的，通过web技术来打包成PC客户端</td>\n</tr>\n<tr>\n<td>移动端</td>\n<td>cordova（旧称PhoneGap），基于cordova的ionicframework</td>\n<td>这种采用h5开发，打包成ipa或apk的应用，称为Hybrid开发（混搭），通过webview实现所谓的跨平台，应用的还是非常广泛的</td>\n</tr>\n</tbody>\n</table>\n<h3>构建工具</h3>\n<p>说起构建工具，大概会想到make、ant、rake、gradle等，其实Node.js里有更多实现</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>介绍</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>jake</td>\n<td>基于coffeescript的大概都熟悉这个，和make、rake类似</td>\n<td>经典传统</td>\n</tr>\n<tr>\n<td>grunt</td>\n<td>dsl风格的早期著名框架</td>\n<td>配置非常麻烦</td>\n</tr>\n<tr>\n<td>gulp</td>\n<td>流式构建，不会产生中间文件，利用Stream机制，处理大文件和内存有优势，配置简单，只有懂点js就能搞定</td>\n<td>grunt的替代品</td>\n</tr>\n<tr>\n<td>webpack + npm scripts</td>\n<td>说是构建工具有点过，但二者组合勉强算吧，loader和plugin机制还是非常强大的</td>\n<td>流行而已</td>\n</tr>\n</tbody>\n</table>\n<p>构建工具都不会特别复杂，所以Node.js世界里有非常多的实现，还有人写过node版本的make呢，玩的很嗨</p>\n<h3>HTTP Proxy</h3>\n<ul>\n<li>请求代理</li>\n<li>SSR &amp;&amp; PWA</li>\n<li>Api Proxy</li>\n</ul>\n<p>1）请求代理</p>\n<p>对于http请求复杂定制的时候，你是需要让Node.js来帮你的，比如为了兼容一个历史遗留需求，在访问某个CSS的时候必须提供HEADER才可以，如果放到静态server或cdn上是做不到的。</p>\n<p>2）SSR &amp;&amp; PWA</p>\n<p>SSR是服务器端渲染，PWA是渐进式Web应用，都是今年最火的技术。如果大家用过，一定对Node.js不陌生。比如React、Vuejs都是Node.js实现的ssr。至于pwa的service-worker也是Node.js实现的。那么为啥不用其他语言实现呢？不是其他语言不能实现，而是使用Node.js简单、方便、学习成本低，轻松获得高性能，如果用其他语言，我至少还得装环境</p>\n<p>3）Api Proxy</p>\n<p>产品需要应变，后端不好变，一变就要设计到数据库、存储等，可能引发事故。而在前端相对更容易，前端只负责组装服务，而非真正对数据库进行变动，所以只要服务api粒度合适，在前端来处理是更好的。</p>\n<p>Api的问题</p>\n<ul>\n<li>一个页面的Api非常多</li>\n<li>跨域，Api转发</li>\n<li>Api返回的数据对前端不友好，后端讨厌（应付）前端，几种api都懒得根据ui/ue去定制，能偷懒就偷懒</li>\n<li>需求决定Api，Api不一定给的及时</li>\n</ul>\n<p>所以，在前端渲染之余，加一层Api Proxy是非常必要的。淘宝早起曾公开过一张架构图，在今天看来，依然不过时</p>\n<p><img src=\"//dn-cnode.qbox.me/Fr8cGvus0i58atULAnoe-Cv4nu5m\" alt=\"taobao.jpg\"></p>\n<ul>\n<li>左侧半边，浏览器和Node.js Server通信可以有多种协议，HTML、RESTfull、BigPipe、Comet、Socket等，已经足够我们完成任何想做的事儿了</li>\n<li>右侧半边，是Node.js实现的WebServer，Node服务分了2个部分\n<ul>\n<li>常规的Http服务，即大块部分二</li>\n<li>ModelProxy指的是根据Server端的服务，组成并转化成自身的Model层。磨蹭用于为Http服务提供更好的接口</li>\n</ul>\n</li>\n</ul>\n<p>这里的Model Proxy其实就是我们所说的Api Proxy，这张图里只是说了结果，把聚合的服务转成模型，继而为HTTP服务提供Api。</p>\n<p>下面我们再深化一下Api Proxy的概念</p>\n<p><img src=\"//dn-cnode.qbox.me/FpAZo4aPQysJyciBvzUCU9uxb-vf\" alt=\"proxy.png\"></p>\n<p>这里的Node Proxy做了2件事儿，Api和渲染辅助。</p>\n<ul>\n<li>前端的异步ajax请求，可以直接访问Api</li>\n<li>如果是直接渲染或者bigpipe等协议的，需要在服务器端组装api，然后再返回给浏览器。</li>\n</ul>\n<p>所以Api后面还有一个服务组装，在微服务架构流行的今天，这种服务组装放到Node Proxy里的好处尤其明显。既可以提高前端开发效率，又可以让后端更加专注于服务开发。甚至如果前端团队足够大，可以在前端建一个Api小组，专门做服务集成的事儿。</p>\n<h3>Api服务</h3>\n<p>说完了Proxy，我们再看看利益问题。Node.js向后端延伸，必然会触动后端开发的利益。那么Proxy层的事儿，前后端矛盾的交界处，后端不想变，前端又求变，那么长此以往，Api接口会变得越来越恶心。后端是愿意把Api的事儿叫前端的，对后端来说，只要你不动我的数据库和服务就可以。</p>\n<p>但是Node.js能不能做这部分呢？答案是能的 ，这个是和Java、PHP类似的，一般是和数据库连接到一起，处理带有业务逻辑的。目前国内大部分都是以Java、PHP等为主，所以要想吃到这部分并不容易。</p>\n<ul>\n<li>小公司，创业公司，新孵化的项目更倾向于Node.js，简单，快速，高效</li>\n<li>微服务架构下的某些服务，使用Node.js开发，是比较合理的</li>\n</ul>\n<p>国内这部分一直没有做的很好，所以Node.js在大公司还没有很好的被应用，安全问题、生态问题、历史遗留问题等，还有很多人对Node.js的误解</p>\n<ul>\n<li>单线程很脆弱，这是事实，但单线程不等于不能多核并发，而且你还有集群呢</li>\n<li>运维，其实很简单，比其他语言之简单，日志采集、监控也非常简单</li>\n<li>模块稳定性，对于Mongodb、MySQL、Redis等还是相当不错，但其他的数据库支持可能没那么好。</li>\n<li>安全问题，</li>\n</ul>\n<p>这些对于提供Api服务来说已经足够了。</p>\n<h3>其他</h3>\n<table>\n<thead>\n<tr>\n<th>用途</th>\n<th>说明</th>\n<th>前景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>爬虫</td>\n<td>抢了不少Python的份额，整体来说简单，实用</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>命令行工具</td>\n<td>写工具、提高效率，node+npm真是无出其右</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>微服务与RPC</td>\n<td>Node做纯后端不好做，但在新项目和微服务架构下，必有一席之地</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>微信公众号开发</td>\n<td>已经火了2年多了，尤其是付费阅读领域，还会继续火下去，gitchat就是使用Node.js做的，而且还在招人</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>反向代理</td>\n<td>Node.js可以作为nginx这样的反向代理，虽然线上我们很少这样做，但它确确实实可以这样做。比如node-http-proxy和anyproxy等，其实使用Node.js做这种请求转发是非常简单的</td>\n<td>看涨</td>\n</tr>\n</tbody>\n</table>\n<h2>更好的写法</h2>\n<h3>Async函数与Promise</h3>\n<ul>\n<li>Async函数是趋势，Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7</a>)了，Node.js 7.0+支持还会远么？</li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。</li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。</li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？</li>\n</ul>\n<p>我整理了一张图，更直观一些。</p>\n<p><img src=\"//dn-cnode.qbox.me/FkcPwxdGHSCHFvA2nU0ub0zYNRt4\" alt=\"async-all.png\"></p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用</li>\n<li>蓝色是Generator，过度货</li>\n<li>绿色是Async函数，趋势</li>\n</ul>\n<p><strong>结论</strong>：Promise是必须会的，那你为什么不顺势而为呢？</p>\n<p><strong>推荐</strong>：使用Async函数 + Promise组合，如下图所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FhVQF1FKB6sNkoFTc3gU-SVnkGtm\" alt=\"async-suggest.png\"></p>\n<p><strong>实践</strong></p>\n<p>合理的结合Promise和Async函数是可以非常高效的，但也要因场景而异</p>\n<ul>\n<li>Promise更容易做promisefyAll（比如使用bluebird）</li>\n<li>Async函数无法批量操作</li>\n</ul>\n<p>那么，在常见的Web应用里，我们总结的实践是，dao层使用Promise比较好，而service层，使用Async/Await更好。</p>\n<p>dao层使用Promise：</p>\n<ul>\n<li>crud</li>\n<li>单一模型的方法多</li>\n<li>库自身支持Promise</li>\n</ul>\n<p>这种用promisefyAll基本几行代码就够了，一般单一模型的操作，不会特别复杂，应变的需求基本不大。</p>\n<p>而service层一般是多个Model组合操作，多模型操作就可以拆分成多个小的操作，然后使用Await来组合，看起来会更加清晰，另外对需求应变也是非常容易的。</p>\n<h3>ES.next</h3>\n<blockquote>\n<p>Node.js + ES.next = ♥</p>\n</blockquote>\n<h3>Flow &amp;&amp; TypeScript</h3>\n<blockquote>\n<p>Type Systems Will Make You a Better JavaScript Developer</p>\n</blockquote>\n<h3>ES6模块</h3>\n<p>现在ES6自带了模块标准， 也是JS第一次支持module（之前的CommonJS、AMD、CMD都不算）， 但目前的所有Node.js版本都没有支持，目前只能用用Traceur、BabelJS， 或者TypeScript把ES6代码转化为兼容ES5版本的js代码，ES6模块新特性非常吸引人，下面简要说明。</p>\n<p>ES6 模块的目标是创建一个同时兼容CommonJS和AMD的格式，语法更加紧凑，通过编译时加载，使得编译时就能确定模块的依赖关系，效率要比 CommonJS 模块的加载方式高。而对于异步加载和配置模块加载方面，则借鉴AMD规范，其效率、灵活程度都远远好于CommonJS写法。</p>\n<ul>\n<li>语法更紧凑</li>\n<li>结构更适于静态编译（比如静态类型检查，优化等）</li>\n<li>对于循环引用支持更好</li>\n</ul>\n<p>ES6 模块标准只有2部分，它的用法更简单，你根本不需要关注实现细节:</p>\n<ul>\n<li>声明式语法：模块导入import、导出export，没有require了</li>\n<li>程式化加载API：可以配置模块是如何加载，以及按需加载。</li>\n</ul>\n<h3>多模块管理器：Lerna</h3>\n<blockquote>\n<p>A tool for managing JavaScript projects with multiple packages.</p>\n</blockquote>\n<p><a href=\"https://lernajs.io/\">https://lernajs.io/</a></p>\n<p>在设计框架的时候，经常做的事儿是进行模块拆分，继而提供插件或集成机制，这样是非常好的做法。但问题也随之而来，当你的模块模块非常多时，你该如何管理你的模块呢？</p>\n<ul>\n<li>法1：每个模块都建立独立的仓库</li>\n<li>法2：所有模块都放到1个仓库里</li>\n</ul>\n<p>法1虽然看起来干净，但模块多时，依赖安装，不同版本兼容等，会导致模块间依赖混乱，出现非常多的重复依赖，极其容易造成版本问题。这时法2就显得更加有效，对于测试，代码管理，发布等，都可以做到更好的支持。</p>\n<p>Lerna就是基于这种初衷而产生的专门用于管理Node.js多模块的工具，当然，前提是你有很多模块需要管理。</p>\n<p>你可以通过npm全局模块来安装Lerna，官方推荐直接使用Lerna 2.x版本</p>\n<h3>更好的NPM替代品：Yarn</h3>\n<p>Yarn是开源JavaScript包管理器，由于npm在扩展内部使用时遇到了大小、性能和安全等问题，Facebook携手来自Exponent、Google和Tilde的工程师，在大型JavaScript框架上打造和测试了Yarn，以便其尽可能适用于多人开发。Yarn承诺比各大流行npm包的安装更可靠，且速度更快。根据你所选的工作包的不同，Yarn可以将安装时间从数分钟减少至几秒钟。Yarn还兼容npm注册表，但包安装方法有所区别。其使用了lockfiles和一个决定性安装算法，能够为参与一个项目的所有用户维持相同的节点模块（node_modules）目录结构，有助于减少难以追踪的bug和在多台机器上复制。</p>\n<p>Yarn还致力于让安装更快速可靠，支持缓存下载的每一个包和并行操作，允许在没有互联网连接的情况下安装（如果此前有安装过的话）。此外，Yarn承诺同时兼容npm和Bower工作流，让你限制安装模块的授权许可。</p>\n<p>2016年10月份, Yarn在横空出世不到一周的时间里，github上的star数已经过万，可以看出大厂及社区的活跃度，以及解决问题的诚意，大概无出其右了！</p>\n<p>替换的原因</p>\n<ul>\n<li>在Facebook的大规模 npm 都工作的不太好</li>\n<li>npm拖慢了公司的ci工作流</li>\n<li>对一个检查所有的模块也是相当低效的</li>\n<li>npm被设计为是不确定性的，而Facebook工程师需要为他们的DevOps工作流提供一直和可依赖的系统</li>\n</ul>\n<p>与hack npm限制的做法相反，Facebook编写了Yarn</p>\n<ul>\n<li>Yarn 的本地缓存文件做的更好</li>\n<li>Yarn 可以并行它的一些操作，这加速了对新模块的安装处理</li>\n<li>Yarn 使用lockfiles，并用确定的算法来创建一个所有跨机器上都一样的文件</li>\n<li>出于安全考虑，在安装进程里，Yarn 不允许编写包的开发者去执行其他代码</li>\n</ul>\n<blockquote>\n<p>Yarn, which promises to even give developers that don’t work at Facebook’s scale a major performance boost, still uses the npm registry and is essentially a drop-in replacement for the npm client.</p>\n</blockquote>\n<p>很多人说和ruby的gem机制类似，都生成lockfile。确实是一个很不错的改进，在速度上有很大改进，配置cnpm等国内源来用，还是相当爽的。</p>\n<h3>友好语言</h3>\n<ul>\n<li>过气的Coffeescript，不多说</li>\n<li><a href=\"https://babeljs.io/\">Babel</a> - also an ES6 to ES5 transpiler that’s growing in popularity possibly because it also supports React’s JSX syntax. As of today it supports the most ES6 features at a somewhat respectable 73%.</li>\n<li><a href=\"http://www.typescriptlang.org/\">TypeScript</a> - a typed superset of JavaScript that not only compiles ES6 to ES5 (or even ES3) but also supports optional variable typing. TypeScript only supports 53% of ES6 features.</li>\n</ul>\n<h2>总结</h2>\n<blockquote>\n<p>坦诚的力量是无穷的</p>\n</blockquote>\n<p>Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。</p>\n<p>直面问题才能有更好的解决方式，Node.js你值得拥有！</p>\n</div>",
            "title": "2017，我们来聊聊 Node.js",
            "last_reply_at": "2017-12-20T07:26:06.107Z",
            "good": true,
            "top": true,
            "reply_count": 176,
            "visit_count": 85335,
            "create_at": "2017-04-13T02:41:41.818Z",
            "author": {
                "loginname": "i5ting",
                "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
            }
        },
        {
            "id": "592917b59e32cc84569a7458",
            "author_id": "54009f5ccd66f2eb37190485",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>本来提供开发api，目的是为了开发第三方应用或客户端，如果大家用来学习也是好的，但现在很多人太过分了，随意发帖，at，严重影响了社区的用户，故而决定开始严查</p>\n<p>以下情况，直接封号</p>\n<ul>\n<li>测试标题</li>\n<li>无任何内容</li>\n<li>无意义回复</li>\n<li>测试帖，5分钟内没有删除</li>\n</ul>\n<p>欢迎大家监督</p>\n<p>封号</p>\n<ul>\n<li><a href=\"https://cnodejs.org/user/Mwangzhi\">https://cnodejs.org/user/Mwangzhi</a></li>\n<li><a href=\"https://cnodejs.org/user/lw6395\">https://cnodejs.org/user/lw6395</a></li>\n<li><a href=\"https://cnodejs.org/user/shengliang74\">https://cnodejs.org/user/shengliang74</a>  竟然挑衅，发帖说你来打我呀。。。。</li>\n<li><a href=\"https://cnodejs.org/user/h5-17\">https://cnodejs.org/user/h5-17</a> <a href=\"/user/h5-17\">@h5-17</a></li>\n<li><a href=\"https://cnodejs.org/user/592php\">https://cnodejs.org/user/592php</a> <a href=\"/user/592php\">@592php</a></li>\n</ul>\n<hr>\n<p>20170601更新</p>\n<p><a href=\"https://cnodejs.org/?tab=dev\">https://cnodejs.org/?tab=dev</a>  目前开了一个『客户端测试』专区，以后开发新客户端的同学，帖子直接发到这个专区去。tab 的值是 dev。</p>\n<p><img src=\"//dn-cnode.qbox.me/FundjyBuYk60yqQ-PdKstrPKY-7-\" alt=\"image.png\"></p>\n</div>",
            "title": "测试请发到客户端测试专区，违规影响用户的，直接封号",
            "last_reply_at": "2017-12-20T02:37:44.795Z",
            "good": false,
            "top": true,
            "reply_count": 143,
            "visit_count": 32119,
            "create_at": "2017-05-27T06:07:49.278Z",
            "author": {
                "loginname": "i5ting",
                "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
            }
        },
        {
            "id": "5a2ffe00d92f2f5b185acde5",
            "author_id": "4efc278525fa69ac6900009e",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><blockquote>\n<p>原文发表于作者的个人博客：<a href=\"http://morning.work/page/nodejs/simple-http-reverse-proxy.html\">http://morning.work/page/nodejs/simple-http-reverse-proxy.html</a>\n转载请注明出处</p>\n</blockquote>\n<p>如果你经常使用 Node.js 编写 Web 服务端程序，一定对使用 Nginx 作为 <a href=\"https://zh.wikipedia.org/zh-hant/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\">反向代理</a> 服务并不陌生。在生产环境中，我们往往需要将程序部署到内网多台服务器上，在一台多核服务器上，为了充分利用所有 CPU 资源，也需要启动多个服务进程，它们分别监听不同的端口。然后使用 Nginx 作为反向代理服务器，接收来自用户浏览器的请求并转发到后端的多台 Web 服务器上。大概工作流程如下图：</p>\n<p><img src=\"http://morning.work/images/2017-12/reverse-server.png\" alt=\"反向代理服务器\"></p>\n<p>在 Node.js 上实现一个简单的 HTTP 代理程序还是非常简单的，本文章的例子的核心代码只有 60 多行，只要理解 <a href=\"https://nodejs.org/api/http.html\">内置 http 模块</a> 的基本用法即可，具体请看下文。</p>\n<h2>接口设计与相关技术</h2>\n<p>使用 <code>http.createServer()</code> 创建的 HTTP 服务器，处理请求的函数格式一般为 <code>function (req, res) {}</code>（下文简称为 <code>requestHandler</code>），其接收两个参数，分别为 <a href=\"https://nodejs.org/api/http.html#http_class_http_incomingmessage\">http.IncomingMessage</a> 和 <a href=\"https://nodejs.org/api/http.html#http_class_http_serverresponse\">http.ServerResponse</a> 对象，我们可以通过这两个对象来取得请求的所有信息并对它进行响应。</p>\n<p>主流的 Node.js Web 框架的中间件（比如 <a href=\"http://npmjs.com/package/connect\">connect</a>）一般都有两种形式：</p>\n<ul>\n<li>中间件不需要任何初始化参数，则其导出结果为一个 <code>requestHandler</code></li>\n<li>中间件需要初始化参数，则其导出结果为中间件的初始化函数，执行该初始化函数时，传入一个 <code>options</code> 对象，执行后返回一个 <code>requestHandler</code></li>\n</ul>\n<p>为了使代码更规范，在本文例子中，我们将反向代理程序设计成一个中间件的格式，并使用以上第二种接口形式：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 生成中间件\nconst handler = reverseProxy({\n  &#x2F;&#x2F; 初始化参数，用于设置目标服务器列表\n  servers: [&quot;127.0.0.1:3001&quot;, &quot;127.0.0.1:3002&quot;, &quot;127.0.0.1:3003&quot;]\n});\n\n&#x2F;&#x2F; 可以直接在 http 模块中使用\nconst server = http.createServer(handler);\n\n&#x2F;&#x2F; 作为中间件在 connect 模块中使用\napp.use(handler);\n</code></pre><p>说明：</p>\n<ul>\n<li>上面的代码中，<code>reverseProxy</code> 是反向代理服务器中间件的初始化函数，它接受一个对象参数，<code>servers</code> 是后端服务器地址列表，每个地址为 <code>IP地址:端口</code> 这样的格式</li>\n<li>执行 <code>reverseProxy()</code> 后返回一个 <code>function (req, res) {}</code> 这样的函数，用于处理 HTTP 请求，可作为 <code>http.createServer()</code> 和 connect 中间件的 <code>app.use()</code> 的处理函数</li>\n<li>当接收到客户端请求时，按顺序循环从 <code>servers</code> 数组中取出一个服务器地址，将请求代理到这个地址的服务器上</li>\n</ul>\n<p>服务器在接收到 HTTP 请求后，首先需要发起一个新的 HTTP 请求到要代理的目标服务器，可以使用 <code>http.request()</code> 来发送请求：</p>\n<pre class=\"prettyprint language-javascript\"><code>const req = http.request(\n  {\n    hostname: &quot;目标服务器地址&quot;,\n    port: &quot;80&quot;,\n    path: &quot;请求路径&quot;,\n    headers: {\n      &quot;x-y-z&quot;: &quot;请求头&quot;\n    }\n  },\n  function(res) {\n    &#x2F;&#x2F; res 为响应对象\n    console.log(res.statusCode);\n  }\n);\n&#x2F;&#x2F; 如果有请求体需要发送，使用 write() 和 end()\nreq.end();\n</code></pre><p>要将客户端的请求体（<code>Body</code> 部分，在 <code>POST</code>、<code>PUT</code> 这些请求时会有请求体）转发到另一个服务器上，可以使用 <code>Stream</code> 对象的 <code>pipe()</code> 方法，比如：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; req 和 res 为客户端的请求和响应对象\n&#x2F;&#x2F; req2 和 res2 为服务器发起的代理请求和响应对象\n&#x2F;&#x2F; 将 req 收到的数据转发到 req2\nreq.pipe(req2);\n&#x2F;&#x2F; 将 res2 收到的数据转发到 res\nres2.pipe(res);\n</code></pre><p>说明：</p>\n<ul>\n<li><code>req</code> 对象是一个 <a href=\"https://nodejs.org/api/stream.html#stream_readable_streams\">Readable Stream</a>（可读流），通过 <code>data</code> 事件来接收数据，当收到 <code>end</code> 事件时表示数据接收完毕</li>\n<li><code>res</code> 对象是一个 <a href=\"https://nodejs.org/api/stream.html#stream_writable_streams\">Writable Stream</a> （可写流），通过 <code>write()</code> 方法来输出数据，<code>end()</code> 方法来结束输出</li>\n<li>为了简化从 <code>Readable Stream</code> 监听 <code>data</code> 事件来获取数据并使用 <code>Writable Stream</code> 的 <code>write()</code> 方法来输出，可以使用 <code>Readable Stream</code> 的 <code>pipe()</code> 方法</li>\n</ul>\n<p>以上只是提到了实现 HTTP 代理需要的关键技术，相关接口的详细文档可以参考这里：<a href=\"https://nodejs.org/api/http.html#http_http_request_options_callback\">https://nodejs.org/api/http.html#http_http_request_options_callback</a></p>\n<p>当然为了实现一个接口友好的程序，往往还需要很多 <em>额外</em> 的工作，具体请看下文。</p>\n<h2>简单版本</h2>\n<p>以下是实现一个简单 HTTP 反向代理服务器的各个文件和代码（没有任何第三方库依赖），<strong>为了使代码更简洁，使用了一些最新的 ES 语法特性，需要使用 Node v8.x 最新版本来运行</strong>：</p>\n<p>文件 <code>proxy.js</code>：</p>\n<pre class=\"prettyprint language-javascript\"><code>const http = require(&quot;http&quot;);\nconst assert = require(&quot;assert&quot;);\nconst log = require(&quot;.&#x2F;log&quot;);\n\n&#x2F;** 反向代理中间件 *&#x2F;\nmodule.exports = function reverseProxy(options) {\n  assert(Array.isArray(options.servers), &quot;options.servers 必须是数组&quot;);\n  assert(options.servers.length &gt; 0, &quot;options.servers 的长度必须大于 0&quot;);\n\n  &#x2F;&#x2F; 解析服务器地址，生成 hostname 和 port\n  const servers = options.servers.map(str =&gt; {\n    const s = str.split(&quot;:&quot;);\n    return { hostname: s[0], port: s[1] || &quot;80&quot; };\n  });\n\n  &#x2F;&#x2F; 获取一个后端服务器，顺序循环\n  let ti = 0;\n  function getTarget() {\n    const t = servers[ti];\n    ti++;\n    if (ti &gt;= servers.length) {\n      ti = 0;\n    }\n    return t;\n  }\n\n  &#x2F;&#x2F; 生成监听 error 事件函数，出错时响应 500\n  function bindError(req, res, id) {\n    return function(err) {\n      const msg = String(err.stack || err);\n      log(&quot;[%s] 发生错误: %s&quot;, id, msg);\n      if (!res.headersSent) {\n        res.writeHead(500, { &quot;content-type&quot;: &quot;text&#x2F;plain&quot; });\n      }\n      res.end(msg);\n    };\n  }\n\n  return function proxy(req, res) {\n    &#x2F;&#x2F; 生成代理请求信息\n    const target = getTarget();\n    const info = {\n      ...target,\n      method: req.method,\n      path: req.url,\n      headers: req.headers\n    };\n\n    const id = &#96;${req.method} ${req.url} =&gt; ${target.hostname}:${target.port}&#96;;\n    log(&quot;[%s] 代理请求&quot;, id);\n\n    &#x2F;&#x2F; 发送代理请求\n    const req2 = http.request(info, res2 =&gt; {\n      res2.on(&quot;error&quot;, bindError(req, res, id));\n      log(&quot;[%s] 响应: %s&quot;, id, res2.statusCode);\n      res.writeHead(res2.statusCode, res2.headers);\n      res2.pipe(res);\n    });\n    req.pipe(req2);\n    req2.on(&quot;error&quot;, bindError(req, res, id));\n  };\n};\n</code></pre><p>文件 <code>log.js</code>：</p>\n<pre class=\"prettyprint language-javascript\"><code>const util = require(&quot;util&quot;);\n\n&#x2F;** 打印日志 *&#x2F;\nmodule.exports = function log(...args) {\n  const time = new Date().toLocaleString();\n  console.log(time, util.format(...args));\n};\n</code></pre><p>说明：</p>\n<ul>\n<li><code>log.js</code> 文件实现了一个用于打印日志的函数 <code>log()</code>，它可以支持 <code>console.log()</code> 一样的用法，并且自动在输出前面加上当前的日期和时间，方便我们浏览日志</li>\n<li><code>reverseProxy()</code> 函数入口使用 <code>assert</code> 模块来进行基本的参数检查，如果参数格式不符合要求即抛出异常，保证可以第一时间让开发者知道，而不是在运行期间发生各种 <em>不可预测</em> 的错误</li>\n<li><code>getTarget()</code> 函数用于循环返回一个目标服务器地址</li>\n<li><code>bindError()</code> 函数用于监听 <code>error</code> 事件，避免整个程序因为没有捕捉网络异常而崩溃，同时可以统一返回出错信息给客户端</li>\n</ul>\n<p>为了测试我们的代码运行的效果，我编写了一个简单的程序，文件 <code>server.js</code>：</p>\n<pre class=\"prettyprint language-javascript\"><code>const http = require(&quot;http&quot;);\nconst log = require(&quot;.&#x2F;log&quot;);\nconst reverseProxy = require(&quot;.&#x2F;proxy&quot;);\n\n&#x2F;&#x2F; 创建反向代理服务器\nfunction startProxyServer(port) {\n  return new Promise((resolve, reject) =&gt; {\n    const server = http.createServer(\n      reverseProxy({\n        servers: [&quot;127.0.0.1:3001&quot;, &quot;127.0.0.1:3002&quot;, &quot;127.0.0.1:3003&quot;]\n      })\n    );\n    server.listen(port, () =&gt; {\n      log(&quot;反向代理服务器已启动: %s&quot;, port);\n      resolve(server);\n    });\n    server.on(&quot;error&quot;, reject);\n  });\n}\n\n&#x2F;&#x2F; 创建演示服务器\nfunction startExampleServer(port) {\n  return new Promise((resolve, reject) =&gt; {\n    const server = http.createServer(function(req, res) {\n      const chunks = [];\n      req.on(&quot;data&quot;, chunk =&gt; chunks.push(chunk));\n      req.on(&quot;end&quot;, () =&gt; {\n        const buf = Buffer.concat(chunks);\n        res.end(&#96;${port}: ${req.method} ${req.url} ${buf.toString()}&#96;.trim());\n      });\n    });\n    server.listen(port, () =&gt; {\n      log(&quot;服务器已启动: %s&quot;, port);\n      resolve(server);\n    });\n    server.on(&quot;error&quot;, reject);\n  });\n}\n\n(async function() {\n  await startExampleServer(3001);\n  await startExampleServer(3002);\n  await startExampleServer(3003);\n  await startProxyServer(3000);\n})();\n</code></pre><p>执行以下命令启动：</p>\n<pre class=\"prettyprint language-bash\"><code>node server.js\n</code></pre><p>然后可以通过 <code>curl</code> 命令来查看返回的结果：</p>\n<pre class=\"prettyprint language-bash\"><code>curl http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;hello&#x2F;world\n</code></pre><p>连续执行多次该命令，如无意外输出结果应该是这样的（输出内容端口部分按照顺序循环）：</p>\n<pre class=\"prettyprint language-text\"><code>3001: GET &#x2F;hello&#x2F;world\n3002: GET &#x2F;hello&#x2F;world\n3003: GET &#x2F;hello&#x2F;world\n3001: GET &#x2F;hello&#x2F;world\n3002: GET &#x2F;hello&#x2F;world\n3003: GET &#x2F;hello&#x2F;world\n</code></pre><p><strong>注意：如果使用浏览器来打开该网址，看到的结果顺序可能是不一样的，因为浏览器会自动尝试请求<code>/favicon</code>，这样刷新一次页面实际上是发送了两次请求。</strong></p>\n<h2>单元测试</h2>\n<p>上文我们已经完成了一个基本的 HTTP 反向代理程序，也通过简单的方法验证了它是能正常工作的。但是，我们并没有足够的测试，比如只验证了 GET 请求，并没有验证 POST 请求或者其他的请求方法。而且通过手工去做更多的测试也比较麻烦，很容易遗漏。所以，接下来我们要给它加上自动化的单元测试。</p>\n<p>在本文中我们选用在 Node.js 界应用广泛的 <a href=\"https://www.npmjs.com/package/mocha\">mocha</a> 作为单元测试框架，搭配使用 <a href=\"https://www.npmjs.com/package/supertest\">supertest</a> 来进行 HTTP 接口请求的测试。由于 <code>supertest</code> 已经自带了一些基本的断言方法，我们暂时不需要 <a href=\"https://www.npmjs.com/package/chai\">chai</a> 或者 <a href=\"https://www.npmjs.com/package/should\">should</a> 这样的第三方断言库。</p>\n<p>首先执行 <code>npm init</code> 初始化一个 <code>package.json</code> 文件，并执行以下命令安装 <code>mocha</code> 和 <code>supertest</code>：</p>\n<pre class=\"prettyprint language-bash\"><code>npm install mocha supertest --save-dev\n</code></pre><p>然后新建文件 <code>test.js</code>：</p>\n<pre class=\"prettyprint language-javascript\"><code>const http = require(&quot;http&quot;);\nconst log = require(&quot;.&#x2F;log&quot;);\nconst reverseProxy = require(&quot;.&#x2F;proxy&quot;);\nconst { expect } = require(&quot;chai&quot;);\nconst request = require(&quot;supertest&quot;);\n\n&#x2F;&#x2F; 创建反向代理服务器\nfunction startProxyServer() {\n  return new Promise((resolve, reject) =&gt; {\n    const server = http.createServer(\n      reverseProxy({\n        servers: [&quot;127.0.0.1:3001&quot;, &quot;127.0.0.1:3002&quot;, &quot;127.0.0.1:3003&quot;]\n      })\n    );\n    log(&quot;反向代理服务器已启动&quot;);\n    resolve(server);\n  });\n}\n\n&#x2F;&#x2F; 创建演示服务器\nfunction startExampleServer(port) {\n  return new Promise((resolve, reject) =&gt; {\n    const server = http.createServer(function(req, res) {\n      const chunks = [];\n      req.on(&quot;data&quot;, chunk =&gt; chunks.push(chunk));\n      req.on(&quot;end&quot;, () =&gt; {\n        const buf = Buffer.concat(chunks);\n        res.end(&#96;${port}: ${req.method} ${req.url} ${buf.toString()}&#96;.trim());\n      });\n    });\n    server.listen(port, () =&gt; {\n      log(&quot;服务器已启动: %s&quot;, port);\n      resolve(server);\n    });\n    server.on(&quot;error&quot;, reject);\n  });\n}\n\ndescribe(&quot;测试反向代理&quot;, function() {\n  let server;\n  let exampleServers = [];\n\n  &#x2F;&#x2F; 测试开始前先启动服务器\n  before(async function() {\n    exampleServers.push(await startExampleServer(3001));\n    exampleServers.push(await startExampleServer(3002));\n    exampleServers.push(await startExampleServer(3003));\n    server = await startProxyServer();\n  });\n\n  &#x2F;&#x2F; 测试结束后关闭服务器\n  after(async function() {\n    for (const server of exampleServers) {\n      server.close();\n    }\n  });\n\n  it(&quot;顺序循环返回目标地址&quot;, async function() {\n    await request(server)\n      .get(&quot;&#x2F;hello&quot;)\n      .expect(200)\n      .expect(&#96;3001: GET &#x2F;hello&#96;);\n\n    await request(server)\n      .get(&quot;&#x2F;hello&quot;)\n      .expect(200)\n      .expect(&#96;3002: GET &#x2F;hello&#96;);\n\n    await request(server)\n      .get(&quot;&#x2F;hello&quot;)\n      .expect(200)\n      .expect(&#96;3003: GET &#x2F;hello&#96;);\n\n    await request(server)\n      .get(&quot;&#x2F;hello&quot;)\n      .expect(200)\n      .expect(&#96;3001: GET &#x2F;hello&#96;);\n  });\n\n  it(&quot;支持 POST 请求&quot;, async function() {\n    await request(server)\n      .post(&quot;&#x2F;xyz&quot;)\n      .send({\n        a: 123,\n        b: 456\n      })\n      .expect(200)\n      .expect(&#96;3002: POST &#x2F;xyz {&quot;a&quot;:123,&quot;b&quot;:456}&#96;);\n  });\n});\n</code></pre><p>说明：</p>\n<ul>\n<li>在单元测试开始前，需要通过 <code>before()</code> 来注册回调函数，以便在开始执行测试用例时先把服务器启动起来</li>\n<li>同理，通过 <code>after()</code> 注册回调函数，以便在执行完所有测试用例后把服务器关闭以释放资源（否则 mocha 进程不会退出）</li>\n<li>使用 <code>supertest</code> 发送请求时，代理服务器不需要监听端口，只需要将 <code>server</code> 实例作为调用参数即可</li>\n</ul>\n<p>接着修改 <code>package.json</code> 文件的 <code>scripts</code> 部分：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;mocha test.js&quot;\n  }\n}\n</code></pre><p>执行以下命令开始测试：</p>\n<pre class=\"prettyprint language-bash\"><code>npm test\n</code></pre><p>如果一切正常，我们应该会看到这样的输出结果，其中 <strong>passing</strong> 这样的提示表示我们的测试完全通过了：</p>\n<pre class=\"prettyprint language-text\"><code>  测试反向代理\n2017-12-12 18:28:15 服务器已启动: 3001\n2017-12-12 18:28:15 服务器已启动: 3002\n2017-12-12 18:28:15 服务器已启动: 3003\n2017-12-12 18:28:15 反向代理服务器已启动\n2017-12-12 18:28:15 [GET &#x2F;hello =&gt; 127.0.0.1:3001] 代理请求\n2017-12-12 18:28:15 [GET &#x2F;hello =&gt; 127.0.0.1:3001] 响应: 200\n2017-12-12 18:28:15 [GET &#x2F;hello =&gt; 127.0.0.1:3002] 代理请求\n2017-12-12 18:28:15 [GET &#x2F;hello =&gt; 127.0.0.1:3002] 响应: 200\n2017-12-12 18:28:15 [GET &#x2F;hello =&gt; 127.0.0.1:3003] 代理请求\n2017-12-12 18:28:15 [GET &#x2F;hello =&gt; 127.0.0.1:3003] 响应: 200\n2017-12-12 18:28:15 [GET &#x2F;hello =&gt; 127.0.0.1:3001] 代理请求\n2017-12-12 18:28:15 [GET &#x2F;hello =&gt; 127.0.0.1:3001] 响应: 200\n    ✓ 顺序循环返回目标地址\n2017-12-12 18:28:15 [POST &#x2F;xyz =&gt; 127.0.0.1:3002] 代理请求\n2017-12-12 18:28:15 [POST &#x2F;xyz =&gt; 127.0.0.1:3002] 响应: 200\n    ✓ 支持 POST 请求\n\n\n  2 passing (45ms)\n</code></pre><p>当然以上的测试代码还远远不够，剩下的就交给读者们来实现了。</p>\n<h2>接口改进</h2>\n<p>如果要设计成一个比较通用的反向代理中间件，我们还可以通过提供一个生成 <a href=\"https://nodejs.org/api/http.html#http_class_http_clientrequest\">http.ClientRequest</a> 的函数来实现在代理时动态修改请求：</p>\n<pre class=\"prettyprint language-javascript\"><code>reverseProxy({\n  servers: [&quot;127.0.0.1:3001&quot;, &quot;127.0.0.1:3002&quot;, &quot;127.0.0.1:3003&quot;],\n  request: function(req, info) {\n    &#x2F;&#x2F; info 是默认生成的 request options 对象\n    &#x2F;&#x2F; 我们可以动态增加请求头，比如当前请求时间戳\n    info.headers[&quot;X-Request-Timestamp&quot;] = Date.now();\n    &#x2F;&#x2F; 返回 http.ClientRequest 对象\n    return http.request(info);\n  }\n});\n</code></pre><p>然后在原来的 <code>http.request(info, (res2) =&gt; {})</code> 部分可以改为监听 <code>response</code> 事件：</p>\n<pre class=\"prettyprint language-javascript\"><code>const req2 = http.request(options.request(info));\nreq2.on(&quot;response&quot;, res2 =&gt; {});\n</code></pre><p>同理，我们也可以通过提供一个函数来修改部分的响应内容：</p>\n<pre class=\"prettyprint language-javascript\"><code>reverseProxy({\n  servers: [&quot;127.0.0.1:3001&quot;, &quot;127.0.0.1:3002&quot;, &quot;127.0.0.1:3003&quot;],\n  response: function(res, info) {\n    &#x2F;&#x2F; info 是发送代理请求时所用的 request options 对象\n    &#x2F;&#x2F; 我们可以动态设置一些响应头，比如实际代理的模板服务器地址\n    res.setHeader(&quot;X-Backend-Server&quot;, &#96;${info.hostname}:${info.port}&#96;);\n  }\n});\n</code></pre><p>此处只发散一下思路，具体实现方法和代码就不再赘述了。</p>\n<h2>总结</h2>\n<p>本文主要介绍了如何使用内置的 <code>http</code> 模块来创建一个 HTTP 服务器，以及发起一个 HTTP 请求，并简单介绍了如何对 HTTP 接口进行测试。在实现 HTTP 请求代理的过程中，主要是运用了 <code>Stream</code> 对象的 <code>pipe()</code> 方法，关键部分代码只有区区几行。Node.js 中的很多程序都运用了 <code>Stream</code> 这样的思想，将数据当做一个流，使用 <code>pipe</code> 将一个流转换成另一个流，可以看出 <code>Stream</code> 在 Node.js 的重要性。关于 <code>Stream</code> 对象的使用方法可以看作者写的另一篇文章 <a href=\"http://morning.work/page/2016-07/readable-stream-and-log-files-processing-in-nodejs.html\">《Node.js 的 Readable Stream 与日志文件处理》</a>。</p>\n</div>",
            "title": "如何编写一个 HTTP 反向代理服务器",
            "last_reply_at": "2017-12-21T04:13:44.204Z",
            "good": true,
            "top": false,
            "reply_count": 6,
            "visit_count": 941,
            "create_at": "2017-12-12T16:04:16.280Z",
            "author": {
                "loginname": "leizongmin",
                "avatar_url": "https://avatars0.githubusercontent.com/u/841625?v=4&s=120"
            }
        },
        {
            "id": "5a3b2e7c8230827a1829391f",
            "author_id": "5a3b2c96d92f2f5b185ad0a7",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>安装vs2013，构建的时候提示头文件找不到<img src=\"//dn-cnode.qbox.me/FoCH3Yht6l7_7Wgre73sdE6Cal1e\" alt=\"ffi_error.png\"></p>\n</div>",
            "title": "安装ffi模块的时候build失败",
            "last_reply_at": "2017-12-21T04:13:30.502Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 24,
            "create_at": "2017-12-21T03:46:04.017Z",
            "author": {
                "loginname": "ElvisWangTech",
                "avatar_url": "https://avatars1.githubusercontent.com/u/23380361?v=4&s=120"
            }
        },
        {
            "id": "5a3a8366d92f2f5b185ad08f",
            "author_id": "53d391a0895ba3062b7ee7f5",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>没事写了个支付宝爬虫，抓了下账户名，余额，花呗信息，还有余额宝余额，没有抓消费记录。</p>\n<p>源代码见：<a href=\"https://github.com/yyrdl/alipay_crawler\">https://github.com/yyrdl/alipay_crawler</a></p>\n</div>",
            "title": "一个简单的支付宝爬虫",
            "last_reply_at": "2017-12-21T04:10:47.281Z",
            "good": false,
            "top": false,
            "reply_count": 5,
            "visit_count": 218,
            "create_at": "2017-12-20T15:36:06.558Z",
            "author": {
                "loginname": "yyrdl",
                "avatar_url": "https://avatars1.githubusercontent.com/u/8213509?v=4&s=120"
            }
        },
        {
            "id": "58f859bd523b9d0956dad7be",
            "author_id": "57aaad434653749872ec6f6b",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>我问一下  koa-jwt 是不是只能验证token，不会生成token， 还是需要jsonwebtoken来生成。 koa-jwt文档里有这句话，英语渣不太懂<img src=\"//dn-cnode.qbox.me/Fhcb7ss0XLabKpcEDofl6EHNs2C8\" alt=\"untitled1.png\"></p>\n</div>",
            "title": "koa-jwt 生成token问题",
            "last_reply_at": "2017-12-21T04:01:40.757Z",
            "good": false,
            "top": false,
            "reply_count": 19,
            "visit_count": 3145,
            "create_at": "2017-04-20T06:48:29.320Z",
            "author": {
                "loginname": "xumjs8623",
                "avatar_url": "https://avatars0.githubusercontent.com/u/12467615?v=4&s=120"
            }
        },
        {
            "id": "5a392a6c8230827a182938a1",
            "author_id": "596eaf6f8f05de0819fdb2fe",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>求大佬们帮助</p>\n</div>",
            "title": "自己刚买的Mac，node出问题，不知道怎么卸载，官网直接下的",
            "last_reply_at": "2017-12-21T03:57:29.077Z",
            "good": false,
            "top": false,
            "reply_count": 10,
            "visit_count": 340,
            "create_at": "2017-12-19T15:04:12.678Z",
            "author": {
                "loginname": "AquariusBaby",
                "avatar_url": "https://avatars0.githubusercontent.com/u/23737877?v=4&s=120"
            }
        },
        {
            "id": "5a32023a9807389a1809f3a6",
            "author_id": "5a31e1a6f15b4f306d2f0320",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>做了2年前端，第一年坚持用jq和原生方式来写代码，css和html都是手写，很少用过第三方ui框架。去年6月份开始接触nodejs。跟着资料把process，fs等模块api都跑了一遍。用express写过一个小博客。今年3月份开始用vue做开发。5月份花了一点时间把koa2源码看了一边，基本理解了内部工作原理。</p>\n<p>从7月分开始使用egg做项目，为了理解mvc的概念，顺便把egg的源码看了一变。了解了egg的内部基本原理(基本上都是一行一行去看，写注释)。准备到年底重构一一遍egg框架\nwebpack等工具也学习过，但是现在不经常看都快忘记了。使用过mongodb做过一个mock系统，用来造假数据给前端使用。</p>\n<p>貌似我都是学而不精。学了很多，忘了很多。期间用vue写了个可定制的app报表模板。</p>\n<p>明年准备看下算法方面知识。</p>\n<p>貌似我这样的前端，前后端都懂一点，都不精通，最近比较迷茫。请教有经验的大佬们给小点一点指引。感激！！</p>\n</div>",
            "title": "请问大佬们，我这样的前端可以找到好工作吗？",
            "last_reply_at": "2017-12-21T03:01:49.343Z",
            "good": false,
            "top": false,
            "reply_count": 20,
            "visit_count": 1160,
            "create_at": "2017-12-14T04:46:50.030Z",
            "author": {
                "loginname": "1316346949",
                "avatar_url": "https://avatars1.githubusercontent.com/u/24400797?v=4&s=120"
            }
        },
        {
            "id": "5a2e716e9807389a1809f2ea",
            "author_id": "511350f6df9e9fcc58856443",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>hi，各位帅气又多金，外表冷酷实则内心热情的技术猿：\n这是考拉拉第二次踏入这片专属程序猿的天地。为了让大家更加全面了解考拉拉背后的大家庭-考拉理财，我们随机采访了公司的程序猿萌，让他们简单描（tu）述（cao）加入考拉理财的内心独白。\n参与者：\nFernando-前端码农，爱笑的大男孩，内心住着一个傲娇的小公举；\nSam-后端码农，一脸淡定的表情，话不投机3句多；\nJamie-全栈程序猿，对简洁整齐的代码有着极致的追求；爱旅游；\nnavy-前端大牛，管理着一个20+的技术团队。\n采访者：考拉拉\n<strong>加入考拉理财，你们的感受是怎样的？</strong>\nFernando：这里的环境好温馨！处处都是卖萌的考拉风，与外面的那些妖艳贱货不一样！中午吃饭还可以一起跟大家组团开黑！还可以让我开发王者农药版的活动页面，每天还有下午茶喝！开熏！\nSam：没什么特别的感受，挺好的；\nJamie：团队的学习氛围很好，虽然平时也会经常出bug，但是跟大家一起讨论总能找到解决方案，蛮有成就感的；\nNavy： 我来考拉2年了，在这里从一名默默无名的码农到现在管理着一个team，我最大的感受就是自己在工作效率以及工作能力方面的进步。很开心遇到一个重视技术团队的CEO。\n<strong>你们在考拉理财印象最深刻的一件事？</strong>\nFernando：公司内部开展“修bug有奖励”，因为自己团队补坑最多，因此拿到了丰厚奖励金！\nSam：月度绩效评比，拿到了E，有了我第一个泷泽萝拉的真人照。感谢组织厚爱。\nJamie：年年都参与了年度旅游，第一年去马来西亚，第二年去泰国，年年都晒成黑炭。但是对于喜欢旅游的我来说，累并快乐着！\nnavy：印象最深的事情，是我第一年来这里的时候，出身软工专业的我却对代码有偏执的情绪，不喜欢撸代码。后面经历了很多的变化，让我逐渐爱上代码，逐渐喜欢在这个团队里跟大家一次干活。也提高了工作效率，也让我有了能力去追逐更好的职位，获得一个宝贵的晋升。\n<strong>一句话形容考拉技术团队？</strong>\nFernando：开黑与无节操齐飞；\nSam：挺好的，我挺喜欢的；\nJamie：团结合作，沟通无阻碍\nNavy：高效快速，能力提升快。\n我说，可以结束这次访谈没。。。\n好了，程序猿们要回家吃饭了，所以这次访谈结束！大家有兴趣了解更多，可以加入我们哟~\n欢迎大家毛遂自荐到此处：jobs@kalengo.com</p>\n</div>",
            "title": "加入考拉理财大家庭，是一种怎样的体验？--来自考拉码农的心声",
            "last_reply_at": "2017-12-21T02:40:21.797Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 452,
            "create_at": "2017-12-11T11:52:14.282Z",
            "author": {
                "loginname": "kalengo",
                "avatar_url": "https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"
            }
        },
        {
            "id": "5a3a402f8230827a182938f7",
            "author_id": "5a3a1e0fd92f2f5b185ad073",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>本人现在一家培训机构学习Node.js，明天要分班，一个方向是Node.js加前段框架，估计是Vue和React之类的，另外一个方向是Node+Python,\n可能会牵扯用Node做游戏之类。\n个人感觉一个方向全栈，另一个更深入后端（？？？）。\n本人对个人的定位尚不明确，希望各位大佬就两者区别以及哪个方向更适合一个初级菜鸟给出建议</p>\n<p>本人之前用express框架独立做了一个小项目，功能只是简单的来回数据调取和修改数据，然后把数据渲染到页面</p>\n<p>以上背景</p>\n</div>",
            "title": "node方向选择，求各位大佬指点...",
            "last_reply_at": "2017-12-21T02:06:08.734Z",
            "good": false,
            "top": false,
            "reply_count": 7,
            "visit_count": 276,
            "create_at": "2017-12-20T10:49:19.907Z",
            "author": {
                "loginname": "Ybx2486241780",
                "avatar_url": "https://avatars2.githubusercontent.com/u/28916253?v=4&s=120"
            }
        },
        {
            "id": "5a27bb6fd3114d3e18fac87c",
            "author_id": "5a2249146190c8912ebaceca",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>在服务端需要即时生成一个类似UUID的ID号，为了能够为记录快速排序，我没有采用真的UUID,而是打算使用“系统当前时间戳”+“i”（ i 是一个范围从1到9999的自增变量）拼接成一个新的整数作为ID，因为JavaScript正常是单线程的（如果采取多线程，我会将不同线程的i的取值范围错开），在单线程高并发（每秒小于i的最大值）请求ID号的情况下，应该是能够保证ID的唯一性的，请问我的这个方案有什么问题吗？</p>\n</div>",
            "title": "这样实时生成的ID唯一性有保证吗？",
            "last_reply_at": "2017-12-21T01:18:42.981Z",
            "good": false,
            "top": false,
            "reply_count": 14,
            "visit_count": 643,
            "create_at": "2017-12-06T09:42:07.282Z",
            "author": {
                "loginname": "lightgm",
                "avatar_url": "https://avatars2.githubusercontent.com/u/20122658?v=4&s=120"
            }
        },
        {
            "id": "56e688a983cbb63b6d120300",
            "author_id": "541bf946ad60405c1f14b770",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h1>koa</h1>\n<p>转载：原文来自 <a href=\"https://github.com/berwin/Blog/issues/8\">https://github.com/berwin/Blog/issues/8</a></p>\n<p>学习koa需要一些相关知识，有两个关键词</p>\n<ul>\n<li>generator</li>\n<li>promise</li>\n</ul>\n<p>本文主要针对koa的原理进行讨论，属于深度篇，并不会对koa的使用过多介绍。</p>\n<p>如果在阅读过程中，发现有哪些地方我写的不太清楚，不容易理解，希望能提出，我会参考建议并进行修改~~</p>\n<h2>koa总体流程图</h2>\n<p>让我们从一张图开始</p>\n<p>&lt;img src=“<a href=\"http://berwin.github.io/ppts/koa/img/koa-flow.jpg\">http://berwin.github.io/ppts/koa/img/koa-flow.jpg</a>” width=“100%”&gt;</p>\n<p>上图中，详细说明了koa从启动server之前，到接受请求在到响应请求的过程中，经历了哪些步骤。</p>\n<p>那我们按照时间线说起~</p>\n<h2>启动前</h2>\n<p>图中有三个蓝色的方块，分别代表三个<code>静态类</code>。</p>\n<p>什么是<code>静态类</code>？这个是我自己给起的名，哈哈</p>\n<p><code>静态类</code>就是程序运行前就存在的方法集合，<code>动态类</code>就是通过代码生成出的方法集合。额，都是我自己起的名，概念也是我自己琢磨的，就是简单归个类。</p>\n<p>三个静态类分别是<code>Request</code>，<code>Context</code>，<code>Response</code></p>\n<p><strong>Request</strong></p>\n<p>Request中包含了一些操作 Node原生请求对象的非常有用的方法。例如获取query数据，获取请求url等，更多方法去查API</p>\n<p><strong>Response</strong></p>\n<p>Response中包含了一些用于设置状态码啦，主体数据啦，header啦，等一些用于操作响应请求的方法。更多方法去查API</p>\n<p><strong>Context</strong></p>\n<p>Context是koa中最重要的概念之一，Context字面意思是上下文，也有环境等意思，koa中的操作都是基于这个context进行的，例如</p>\n<pre class=\"prettyprint language-javascript\"><code>this.body = &#x27;hello world&#x27;;\n</code></pre><p>从前面的图中，启动前的三个蓝色方块可以看到，左边的Request和右边的Response各有一个箭头指向Context，表示Request和Response自身的方法会委托到Context中。</p>\n<p>Context中有两部分，一部分是自身属性，主要是应用于框架内部使用，一部分是Request和Response委托的操作方法，主要为提供给用户更方便从Request获取想要的参数和更方便的设置Response内容。</p>\n<p>下面是Context源码片段。</p>\n<pre class=\"prettyprint language-javascript\"><code>var delegate = require(&#x27;delegates&#x27;);\nvar proto = module.exports = {}; &#x2F;&#x2F; 一些自身方法，被我删了\n\n&#x2F;**\n * Response delegation.\n *&#x2F;\n\ndelegate(proto, &#x27;response&#x27;)\n  .method(&#x27;attachment&#x27;)\n  .method(&#x27;redirect&#x27;)\n  .method(&#x27;remove&#x27;)\n  .method(&#x27;vary&#x27;)\n  .method(&#x27;set&#x27;)\n  .method(&#x27;append&#x27;)\n  .access(&#x27;status&#x27;)\n  .access(&#x27;message&#x27;)\n  .access(&#x27;body&#x27;)\n  .access(&#x27;length&#x27;)\n  .access(&#x27;type&#x27;)\n  .access(&#x27;lastModified&#x27;)\n  .access(&#x27;etag&#x27;)\n  .getter(&#x27;headerSent&#x27;)\n  .getter(&#x27;writable&#x27;);\n\n&#x2F;**\n * Request delegation.\n *&#x2F;\n\ndelegate(proto, &#x27;request&#x27;)\n  .method(&#x27;acceptsLanguages&#x27;)\n  .method(&#x27;acceptsEncodings&#x27;)\n  .method(&#x27;acceptsCharsets&#x27;)\n  .method(&#x27;accepts&#x27;)\n  .method(&#x27;get&#x27;)\n  .method(&#x27;is&#x27;)\n  .access(&#x27;querystring&#x27;)\n  .access(&#x27;idempotent&#x27;)\n  .access(&#x27;socket&#x27;)\n  .access(&#x27;search&#x27;)\n  .access(&#x27;method&#x27;)\n  .access(&#x27;query&#x27;)\n  .access(&#x27;path&#x27;)\n  .access(&#x27;url&#x27;)\n  .getter(&#x27;origin&#x27;)\n  .getter(&#x27;href&#x27;)\n  .getter(&#x27;subdomains&#x27;)\n  .getter(&#x27;protocol&#x27;)\n  .getter(&#x27;host&#x27;)\n  .getter(&#x27;hostname&#x27;)\n  .getter(&#x27;header&#x27;)\n  .getter(&#x27;headers&#x27;)\n  .getter(&#x27;secure&#x27;)\n  .getter(&#x27;stale&#x27;)\n  .getter(&#x27;fresh&#x27;)\n  .getter(&#x27;ips&#x27;)\n  .getter(&#x27;ip&#x27;);\n</code></pre><p>delegates是第三方npm包，功能就是把一个对象上的方法，属性委托到另一个对象上</p>\n<p>对了，你猜对了，上面那一排方法，都是Request和Response静态类中的方法，有点看目录的感觉~</p>\n<p>method方法是委托方法，getter方法用来委托getter，access方法委托getter+setter</p>\n<p>下面是源码片段</p>\n<pre class=\"prettyprint language-javascript\"><code>function Delegator(proto, target) {\n  if (!(this instanceof Delegator)) return new Delegator(proto, target);\n  this.proto = proto;\n  this.target = target;\n  this.methods = [];\n  this.getters = [];\n  this.setters = [];\n  this.fluents = [];\n}\n\nDelegator.prototype.method = function(name){\n  var proto = this.proto;\n  var target = this.target;\n  this.methods.push(name);\n\n  proto[name] = function(){\n    return this[target][name].apply(this[target], arguments);\n  };\n\n  return this;\n};\n</code></pre><p>从上面的代码中可以看到，它其实是在proto上新建一个与Request和Response上的方法名一样的函数，然后执行这个函数的时候，这个函数在去Request和Response上去找对应的方法并执行。</p>\n<p>简单来个栗子</p>\n<pre class=\"prettyprint language-javascript\"><code>var proto = {};\n\nvar Request = {\n  test: function () {\n    console.log(&#x27;test&#x27;);\n  }\n};\n\nvar name = &#x27;test&#x27;;\nproto[name] = function () {\n  return Request[name].apply(Request, arguments);\n};\n</code></pre><p>我们在来看看getter方法</p>\n<pre class=\"prettyprint language-javascript\"><code>Delegator.prototype.getter = function(name){\n  var proto = this.proto;\n  var target = this.target;\n  this.getters.push(name);\n\n  proto.__defineGetter__(name, function(){\n    return this[target][name];\n  });\n\n  return this;\n};\n</code></pre><p>可以看到，在proto上绑定个getter函数，当函数被触发的时候去，会去对应的request或response中去读取对应的属性，这样request或response的getter同样会被触发~</p>\n<p>我们在来看看access</p>\n<pre class=\"prettyprint language-javascript\"><code>Delegator.prototype.access = function(name){\n  return this.getter(name).setter(name);\n};\n</code></pre><p>可以看到，这个方法是getter+setter，getter上面刚说过，setter与getter同理，不多说了，心好累…</p>\n<p>应用启动前的内容到现在就说完了，接下来我们看看使用koa来启动一个app的时候，koa内部会发生什么呢？</p>\n<h2>启动server</h2>\n<p>我们使用koa来启动server的时候有两个步骤。第一步是init一个app对象，第二步是用app对象监听下端口号，一个server就启动好了。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 第一步 - 初始化app对象\nvar koa = require(&#x27;koa&#x27;);\nvar app = koa();\n\n&#x2F;&#x2F; 第二步 - 监听端口\napp.listen(1995);\n</code></pre><p>简单吧？</p>\n<p>不了解内部机制的同学，通常会认为server是在<code>koa()</code>这个时候启动的，<code>app.listen</code>只是监听下端口而已~</p>\n<p>事实上。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。并不是。</p>\n<p>有木有被刷新三观？？？</p>\n<p>我们看下源码片段</p>\n<pre class=\"prettyprint language-javascript\"><code>module.exports = Application;\n\nfunction Application() {\n  if (!(this instanceof Application)) return new Application;\n  this.env = process.env.NODE_ENV || &#x27;development&#x27;;\n  this.subdomainOffset = 2;\n  this.middleware = [];\n  this.proxy = false;\n  this.context = Object.create(context);\n  this.request = Object.create(request);\n  this.response = Object.create(response);\n}\n</code></pre><p>从源码中可以看到，执行<code>koa()</code>的时候初始化了一些很有用的东西，包括初始化一个空的中间件集合，基于Request，Response，Context为原型，生成实例等操作。</p>\n<p><strong>Request和Response的属性和方法委托到Context中也是在这一步进行的</strong></p>\n<p>并没有启动server</p>\n<p>我们看第二步，在看一段源码</p>\n<pre class=\"prettyprint language-javascript\"><code>app.listen = function(){\n  debug(&#x27;listen&#x27;);\n  var server = http.createServer(this.callback());\n  return server.listen.apply(server, arguments);\n};\n</code></pre><p>可以看到，在执行<code>app.listen(1995)</code>的时候，启动了一个server，并且监听端口。熟悉nodejs的同学知道http.createServer接收一个函数作为参数，每次服务器接收到请求都会执行这个函数，并传入两个参数（request和response，简称req和res），那么现在重点在<code>this.callback</code>这个方法上。</p>\n<p>我们一起看一下<code>this.callback</code>是何方神圣</p>\n<pre class=\"prettyprint language-javascript\"><code>app.callback = function(){\n  if (this.experimental) {\n    console.error(&#x27;Experimental ES7 Async Function support is deprecated. Please look into Koa v2 as the middleware signature has changed.&#x27;)\n  }\n  var fn = this.experimental\n    ? compose_es7(this.middleware)\n    : co.wrap(compose(this.middleware));\n  var self = this;\n\n  if (!this.listeners(&#x27;error&#x27;).length) this.on(&#x27;error&#x27;, this.onerror);\n\n  return function(req, res){\n    res.statusCode = 404;\n    var ctx = self.createContext(req, res);\n    onFinished(res, ctx.onerror);\n    fn.call(ctx).then(function () {\n      respond.call(ctx);\n    }).catch(ctx.onerror);\n  }\n};\n</code></pre><p><strong>这个方法其实可以分成两部分，一部分是执行函数的那一瞬间所执行的代码，另一部分是接收请求的时候所执行的代码。</strong></p>\n<p>而前一部分就是总体流程图中，启动server这个时间段，黄色椭圆形所执行的那一部分，<strong>初始化中间件！！！</strong></p>\n<h3>第一部分</h3>\n<p>先说第一部分，很明显，这环节是在<strong>初始化中间件</strong>，那为什么要初始化中间件呢？处理后的中间件与处理之前的中间件又有什么不同呢？？？？</p>\n<p>童鞋，，，不要着急，听我慢慢道来~~</p>\n<p>我们添加中间的时候使用<code>app.use</code>方法，其实这个方法只是把中间件push到一个数组，然后就没有然后了。。(⊙﹏⊙)</p>\n<p>很明显，所有中间件都在数组中，那么它们之间是没有联系的，如果没有联系，就不可能实现<code>流水线</code>这样的功能。。。。</p>\n<p>那么这些中间件处理之后会变成什么样的？？？？</p>\n<p>我们先看代码，上面的代码中用<code>this.experimental</code>这个属性做了一个判断。这个属性是什么鸟。</p>\n<p><code>this.experimental</code> 关于这个属性我并没有在官方文档上看到说明，但以我对koa的了解，这个方法是为了判断是否支持es7，默认是不支持的，如果想支持，需要在代码中明确指定<code>this.experimental = true</code>，开启这个属性之后，中间件可以传入async函数。</p>\n<p>我想说的是，无论是否开启ES7，原理都是相同的，只是因为语法特性的不同，需要不同的处理，核心思想不会因为不同的语言特性而改变，支持ES7显然处理起来更方便，因为默认不开启<code>this.experimental</code>，所以这里我们针对不开启的情况进行讨论~</p>\n<p>这样一来，第一部分的代码就简化成了这样</p>\n<pre class=\"prettyprint language-javascript\"><code>var fn = co.wrap(compose(this.middleware));\n</code></pre><p>虽然只剩下一行代码，但不要小瞧它哦~~</p>\n<p>我们先看<code>compose(this.middleware)</code>这部分，<code>compose</code>的全名叫<code>koa-compose</code>，他的作用是把一个个不相干的中间件串联在一起。。</p>\n<p>例如</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 有3个中间件\nthis.middlewares = [function *m1() {}, function *m2() {}, function *m3() {}];\n\n&#x2F;&#x2F; 通过compose转换\nvar middleware = compose(this.middlewares);\n\n&#x2F;&#x2F; 转换后得到的middleware是这个样子的\nfunction *() {\n  yield *m1(m2(m3(noop())))\n}\n</code></pre><p>有木有很神奇的感觉？？更神奇的是，generator函数的特性是，第一次执行并不会执行函数里的代码，而是生成一个generator对象，这个对象有next，throw等方法。</p>\n<p><strong>这就造成了一个现象，每个中间件都会有一个参数，这个参数就是下一个中间件执行后，生成出来的generator对象</strong>，没错，这就是大名鼎鼎的 <strong>next</strong></p>\n<p>那<code>compose</code>是如何实现这样的功能的呢？？我们看一下代码</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * Expose compositor.\n *&#x2F;\n\nmodule.exports = compose;\n\n&#x2F;**\n * Compose &#96;middleware&#96; returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n *&#x2F;\n\nfunction compose(middleware){\n  return function *(next){\n    if (!next) next = noop();\n\n    var i = middleware.length;\n\n    while (i--) {\n      next = middleware[i].call(this, next);\n    }\n\n    return yield *next;\n  }\n}\n\n&#x2F;**\n * Noop.\n *\n * @api private\n *&#x2F;\n\nfunction *noop(){}\n</code></pre><p>这是这个模块的所有代码，很简单，逻辑是这样的</p>\n<p>先把中间件从后往前依次执行，并把每一个中间件执行后得到的generator对象赋值给变量next，当下一次执行中间件的时候（也就是执行前一个中间件的时候），把next传给第一个参数。这样就保证前一个中间件的参数是下一个中间件生成的generator对象，第一次执行的时候next为<code>noop</code>，<code>noop</code>是空的generator函数。</p>\n<p>koa的中间件必须为generator函数（就是带星号的函数），否则无法顺利的执行中间件逻辑</p>\n<p>最后，有一个非常巧妙的地方，就是最后一行<code>return yield *next;</code></p>\n<p>这行代码可以实现把<code>compose</code>执行后return的函数变成第一个中间件，也就是说，执行<code>compose</code>之后会得到一个函数，执行这个函数就与执行第一个中间件的效果是一模一样的，这主要依赖了generator函数的yield *语句的特性。</p>\n<p>现在中间件的状态就已经从<code>不可用</code>变成<code>可用</code>了。不可用的中间件是一个数组，可用的中间件是一个<strong>generator函数</strong>。</p>\n<p>我们接着说刚才没说完的</p>\n<pre class=\"prettyprint language-javascript\"><code>var fn = co.wrap(compose(this.middleware));\n</code></pre><p>上面这段代码现在就可以理解成下面这样</p>\n<pre class=\"prettyprint language-javascript\"><code>var fn = co.wrap(function *() {yield *m1(m2(m3(noop())))});\n</code></pre><p>里面的函数刚刚已经说过是可用状态的中间件，那么<code>co.wrap</code>是干什么用的呢？？</p>\n<p>co是TJ大神基于Generator开发的一款流程控制模块，白话文就是：就是把异步变成同步的模块。。。（感觉逼格瞬间拉低了。。。）</p>\n<p>看下源码</p>\n<pre class=\"prettyprint language-javascript\"><code>co.wrap = function (fn) {\n  createPromise.__generatorFunction__ = fn;\n  return createPromise;\n  function createPromise() {\n    return co.call(this, fn.apply(this, arguments));\n  }\n};\n</code></pre><p>从源码中可以看到，它接收一个参数，这个参数就是可用状态下的中间件，返回一个函数createPromise，当执行createPromise这个函数的时候，调用co并传入一个参数，这个参数是中间件函数执行后生成的Generator对象。</p>\n<p><strong>这意味着，返回的这个函数是触发执行中间件逻辑的关键，一旦这个函数被执行，那么就会开始执行中间件逻辑</strong></p>\n<pre class=\"prettyprint language-javascript\"><code>app.callback = function(){\n  if (this.experimental) {\n    console.error(&#x27;Experimental ES7 Async Function support is deprecated. Please look into Koa v2 as the middleware signature has changed.&#x27;)\n  }\n  var fn = this.experimental\n    ? compose_es7(this.middleware)\n    : co.wrap(compose(this.middleware));\n  var self = this;\n\n  if (!this.listeners(&#x27;error&#x27;).length) this.on(&#x27;error&#x27;, this.onerror);\n\n  return function(req, res){\n    res.statusCode = 404;\n    var ctx = self.createContext(req, res);\n    onFinished(res, ctx.onerror);\n    fn.call(ctx).then(function () {\n      respond.call(ctx);\n    }).catch(ctx.onerror);\n  }\n};\n</code></pre><p>从源码中，可以看到这个函数赋值给fn，fn是在下面那个函数中执行的，下面那个函数是接下来要说的内容~</p>\n<p>到现在，我们的koa已经处于一种待机状态，所有准备都以准备好（中间件和context），万事俱备，只欠东风。。。。。。</p>\n<p>东风就是request请求~~</p>\n<h2>接收请求</h2>\n<p>前面说了启动前的一些准备工作和启动时的初始化工作，现在最后一步就是接收请求的时候，koa要做的事情了，这部分也是koa中难度最大的一部分。不过认真阅读下去会有收获的。。</p>\n<p>上面我们说<code>this.callback</code>这个方法有两个部分，第一个部分是初始化中间件，而另一部分就是接收请求时执行的函数啦。</p>\n<p>简单回顾下</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 创建server并监听端口\napp.listen = function(){\n  debug(&#x27;listen&#x27;);\n  var server = http.createServer(this.callback());\n  return server.listen.apply(server, arguments);\n};\n\n&#x2F;&#x2F; 这个方法返回的函数会被传递到http.createServer中，http.createServer这个方法的作用是每当服务器接收到请求的时候，都会执行第一个参数，并且会传递request和response\napp.callback = function(){\n  if (this.experimental) {\n    console.error(&#x27;Experimental ES7 Async Function support is deprecated. Please look into Koa v2 as the middleware signature has changed.&#x27;)\n  }\n  var fn = this.experimental\n    ? compose_es7(this.middleware)\n    : co.wrap(compose(this.middleware));\n  var self = this;\n\n  if (!this.listeners(&#x27;error&#x27;).length) this.on(&#x27;error&#x27;, this.onerror);\n\n  return function(req, res){\n    res.statusCode = 404;\n    var ctx = self.createContext(req, res);\n    onFinished(res, ctx.onerror);\n    fn.call(ctx).then(function () {\n      respond.call(ctx);\n    }).catch(ctx.onerror);\n  }\n};\n</code></pre><p>所以第二部分的重点就是下面段代码啦~</p>\n<pre class=\"prettyprint language-javascript\"><code>return function(req, res){\n  res.statusCode = 404;\n  var ctx = self.createContext(req, res);\n  onFinished(res, ctx.onerror);\n  fn.call(ctx).then(function () {\n    respond.call(ctx);\n  }).catch(ctx.onerror);\n}\n</code></pre><p>我们先看这段代码</p>\n<pre class=\"prettyprint language-javascript\"><code>var ctx = self.createContext(req, res);\n</code></pre><p>不知道各位童鞋还记不记得文章一开始的时候那个总体流程图下面的那个类似于八卦一样的东西？？？</p>\n<p>这行代码就是创建一个最终可用版的context。</p>\n<p>&lt;img src=“<a href=\"http://berwin.github.io/ppts/koa/img/context.png\">http://berwin.github.io/ppts/koa/img/context.png</a>” width=“100%”&gt;</p>\n<p>从上图中，可以看到分别有五个箭头指向ctx，表示ctx上包含5个属性，分别是request，response，req，res，app。request和response也分别有5个箭头指向它们，所以也是同样的逻辑。</p>\n<p>这里需要说明下</p>\n<ul>\n<li>request - request继承于Request静态类，包含操作request的一些常用方法</li>\n<li>response - response继承于Response静态类，包含操作response的一些常用方法</li>\n<li>req - nodejs原生的request对象</li>\n<li>res - nodejs原生的response对象</li>\n<li>app - koa的原型对象</li>\n</ul>\n<p>不多说，咱们观摩下代码</p>\n<pre class=\"prettyprint language-javascript\"><code>app.createContext = function(req, res){\n  \n  &#x2F;&#x2F; 继承\n  var context = Object.create(this.context);\n  var request = context.request = Object.create(this.request);\n  var response = context.response = Object.create(this.response);\n  \n  &#x2F;&#x2F; 往context，request，response身上挂载属性\n  context.app = request.app = response.app = this;\n  context.req = request.req = response.req = req;\n  context.res = request.res = response.res = res;\n  request.ctx = response.ctx = context;\n  request.response = response;\n  response.request = request;\n  context.onerror = context.onerror.bind(context);\n  context.originalUrl = request.originalUrl = req.url;\n  context.cookies = new Cookies(req, res, {\n    keys: this.keys,\n    secure: request.secure\n  });\n  context.accept = request.accept = accepts(req);\n  context.state = {};\n  \n  &#x2F;&#x2F; 最后返回完整版context\n  return context;\n};\n</code></pre><p>讲到这里其实我可以很明确的告诉大家，，，koa中的<code>this</code>其实就是<code>app.createContext</code>方法返回的完整版<code>context</code></p>\n<p>又由于这段代码的执行时间是接受请求的时候，所以表明<strong>每一次接受到请求，都会为该请求生成一个新的上下文</strong></p>\n<p>上下文到这里我们就说完啦。我们接着往下说，看下一行代码</p>\n<pre class=\"prettyprint language-javascript\"><code>onFinished(res, ctx.onerror);\n</code></pre><p>这行代码其实很简单，就是监听response，如果response有错误，会执行<code>ctx.onerror</code>中的逻辑，设置response类型，状态码和错误信息等。</p>\n<p>源码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>onerror: function(err){\n  &#x2F;&#x2F; don&#x27;t do anything if there is no error.\n  &#x2F;&#x2F; this allows you to pass &#96;this.onerror&#96;\n  &#x2F;&#x2F; to node-style callbacks.\n  if (null == err) return;\n\n  if (!(err instanceof Error)) err = new Error(&#x27;non-error thrown: &#x27; + err);\n\n  &#x2F;&#x2F; delegate\n  this.app.emit(&#x27;error&#x27;, err, this);\n\n  &#x2F;&#x2F; nothing we can do here other\n  &#x2F;&#x2F; than delegate to the app-level\n  &#x2F;&#x2F; handler and log.\n  if (this.headerSent || !this.writable) {\n    err.headerSent = true;\n    return;\n  }\n\n  &#x2F;&#x2F; unset all headers\n  this.res._headers = {};\n\n  &#x2F;&#x2F; force text&#x2F;plain\n  this.type = &#x27;text&#x27;;\n\n  &#x2F;&#x2F; ENOENT support\n  if (&#x27;ENOENT&#x27; == err.code) err.status = 404;\n\n  &#x2F;&#x2F; default to 500\n  if (&#x27;number&#x27; != typeof err.status || !statuses[err.status]) err.status = 500;\n\n  &#x2F;&#x2F; respond\n  var code = statuses[err.status];\n  var msg = err.expose ? err.message : code;\n  this.status = err.status;\n  this.length = Buffer.byteLength(msg);\n  this.res.end(msg);\n}\n</code></pre><p>我们接着说，还有最后一个知识点，也是本章最复杂的知识点，关于中间件的执行流程，这里会说明为什么koa的中间件可以回逆。</p>\n<p>我们先看代码</p>\n<pre class=\"prettyprint language-javascript\"><code>fn.call(ctx).then(function () {\n  respond.call(ctx);\n}).catch(ctx.onerror);\n</code></pre><ul>\n<li>fn - 我们上面讲的<code>co.wrap</code>返回的那个函数</li>\n<li>ctx - app.createContext执行后返回的完整版context对象</li>\n</ul>\n<p>总体上来说，执行<code>fn.call(ctx)</code>会返回promise，koa会监听执行的成功和失败，成功则执行<code>respond.call(ctx);</code>，失败则执行<code>ctx.onerror</code>，失败的回调函数刚刚已经讲过。这里先说说<code>respond.call(ctx);</code>。</p>\n<p>我们在写koa的时候，会发现所有的response操作都是\n<code>this.body = xxx;</code> <code>this.status = xxxx;</code>这样的语法，但如果对原生nodejs有了解的童鞋知道，nodejs的response只有一个api那就是<code>res.end();</code>，而设置status状态码什么的都有不同的api，那么koa是如何做到通过<code>this.xxx = xxx</code>来设置response的呢？</p>\n<p>先看一张图，，我盗的图</p>\n<p>&lt;img src=“<a href=\"http://berwin.github.io/ppts/koa/img/process_koa.png\">http://berwin.github.io/ppts/koa/img/process_koa.png</a>” width=“100%”&gt;</p>\n<p>从图中看到，request请求是以respond结束的。</p>\n<p>是滴，所有的request请求都是以respond这个函数结束的，这个函数会读取this.body中的值根据不同的类型来决定以什么类型响应请求</p>\n<p>我们来欣赏一下源码</p>\n<pre class=\"prettyprint language-javascript\"><code>function respond() {\n  &#x2F;&#x2F; allow bypassing koa\n  if (false === this.respond) return;\n\n  var res = this.res;\n  if (res.headersSent || !this.writable) return;\n\n  var body = this.body;\n  var code = this.status;\n\n  &#x2F;&#x2F; ignore body\n  if (statuses.empty[code]) {\n    &#x2F;&#x2F; strip headers\n    this.body = null;\n    return res.end();\n  }\n\n  if (&#x27;HEAD&#x27; == this.method) {\n    if (isJSON(body)) this.length = Buffer.byteLength(JSON.stringify(body));\n    return res.end();\n  }\n\n  &#x2F;&#x2F; status body\n  if (null == body) {\n    this.type = &#x27;text&#x27;;\n    body = this.message || String(code);\n    this.length = Buffer.byteLength(body);\n    return res.end(body);\n  }\n\n  &#x2F;&#x2F; responses\n  if (Buffer.isBuffer(body)) return res.end(body);\n  if (&#x27;string&#x27; == typeof body) return res.end(body);\n  if (body instanceof Stream) return body.pipe(res);\n\n  &#x2F;&#x2F; body: json\n  body = JSON.stringify(body);\n  this.length = Buffer.byteLength(body);\n  res.end(body);\n}\n</code></pre><p>仔细阅读的童鞋会发现，咦，，，，为毛没有设置status和header等信息的代码逻辑？这不科学啊。我分明记得状态码是<code>rs.statusCode = 400</code>这样设置的，为啥代码中没有？？</p>\n<p>这就要从最开始的上下文说起了。为什么Response静态类中添加req和res属性？就是因为添加了req和res之后，response和request类就可以直接操作req和res啦。。我们看一段源码就明白了</p>\n<pre class=\"prettyprint language-javascript\"><code>set status(code) {\n  assert(&#x27;number&#x27; == typeof code, &#x27;status code must be a number&#x27;);\n  assert(statuses[code], &#x27;invalid status code: &#x27; + code);\n  this._explicitStatus = true;\n  this.res.statusCode = code;\n  this.res.statusMessage = statuses[code];\n  if (this.body &amp;&amp; statuses.empty[code]) this.body = null;\n},\n</code></pre><p>主要是<code>this.res.statusCode = code;</code> <code>this.res.statusMessage = statuses[code];</code>这两句，<code>statusCode</code>和<code>statusMessage</code>都是nodejs原生api。有兴趣可以自行查看~</p>\n<p>接下来我们开始说说koa的中间件为什么可以回逆，为什么koa的中间件必须使用generator，yield next又是个什么鬼？</p>\n<p>我们看这段代码</p>\n<pre class=\"prettyprint language-javascript\"><code>fn.call(ctx)\n</code></pre><p>fn刚刚上面说过，就是<code>co.wrap</code>返回的那个函数，上面也说过，一旦这个函数执行，就会执行中间件逻辑，并且通过<code>.call</code>把<code>ctx</code>设为上下文，也就是this。</p>\n<p>那中间件逻辑是什么样的呢。我们先看一下源码：</p>\n<pre class=\"prettyprint language-javascript\"><code>co.wrap = function (fn) {\n  createPromise.__generatorFunction__ = fn;\n  return createPromise;\n  function createPromise() {\n    return co.call(this, fn.apply(this, arguments));\n  }\n};\n</code></pre><p>先回顾下，createPromise就是fn，每当执行createPromise的时候，都会执行co，中间件是基于co实现的、所以我们接下来要说的是co的实现逻辑。而执行co所传递的那个参数，我们给它起个名，就叫<code>中间件函数</code>吧，中间件函数也是一个generator函数，因为在执行co的时候执行了这个中间件函数，所以实际上真正传递给co的参数是一个generator对象，为了方便理解，我们先起个名叫<code>中间件对象吧</code></p>\n<p>那我们看co的源码：</p>\n<pre class=\"prettyprint language-javascript\"><code>function co(gen) {\n  var ctx = this;\n  var args = slice.call(arguments, 1)\n\n  &#x2F;&#x2F; we wrap everything in a promise to avoid promise chaining,\n  &#x2F;&#x2F; which leads to memory leak errors.\n  &#x2F;&#x2F; see https:&#x2F;&#x2F;github.com&#x2F;tj&#x2F;co&#x2F;issues&#x2F;180\n  return new Promise(function(resolve, reject) {\n    if (typeof gen === &#x27;function&#x27;) gen = gen.apply(ctx, args);\n    if (!gen || typeof gen.next !== &#x27;function&#x27;) return resolve(gen);\n\n    onFulfilled();\n\n    &#x2F;**\n     * @param {Mixed} res\n     * @return {Promise}\n     * @api private\n     *&#x2F;\n\n    function onFulfilled(res) {\n      var ret;\n      try {\n        ret = gen.next(res);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n    &#x2F;**\n     * @param {Error} err\n     * @return {Promise}\n     * @api private\n     *&#x2F;\n\n    function onRejected(err) {\n      var ret;\n      try {\n        ret = gen.throw(err);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n    &#x2F;**\n     * Get the next value in the generator,\n     * return a promise.\n     *\n     * @param {Object} ret\n     * @return {Promise}\n     * @api private\n     *&#x2F;\n\n    function next(ret) {\n      if (ret.done) return resolve(ret.value);\n      var value = toPromise.call(ctx, ret.value);\n      if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);\n      return onRejected(new TypeError(&#x27;You may only yield a function, promise, generator, array, or object, &#x27;\n        + &#x27;but the following object was passed: &quot;&#x27; + String(ret.value) + &#x27;&quot;&#x27;));\n    }\n  });\n}\n</code></pre><p>可以看到，代码并不是很多。</p>\n<p>首先执行co会返回一个promise，koa会对这个promise的成功和失败都准备了不同的处理，上面已经说过。</p>\n<p>我们在看这段代码</p>\n<pre class=\"prettyprint language-javascript\"><code>function onFulfilled(res) {\n  var ret;\n  try {\n    ret = gen.next(res);\n  } catch (e) {\n    return reject(e);\n  }\n  next(ret);\n}\n</code></pre><p>这个函数最重要的作用是运行<code>gen.next</code>来执行中间件中的业务逻辑。</p>\n<p>通常在开发中间件的时候会这样写</p>\n<pre class=\"prettyprint language-javascript\"><code>yield next;\n</code></pre><p>所以ret中包含下一个<code>中间件对象</code>（还记得上面我们初始化中间件的时候中间件的参数是什么了吗？？）</p>\n<p>然后把下一个中间件对象传到了<code>next(ret)</code>这个函数里，next函数是干什么的？我们看看</p>\n<pre class=\"prettyprint language-javascript\"><code>function next(ret) {\n  if (ret.done) return resolve(ret.value);\n  var value = toPromise.call(ctx, ret.value);\n  if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);\n  return onRejected(new TypeError(&#x27;You may only yield a function, promise, generator, array, or object, &#x27;\n    + &#x27;but the following object was passed: &quot;&#x27; + String(ret.value) + &#x27;&quot;&#x27;));\n}\n</code></pre><p>可以看到，逻辑是这样的</p>\n<p>如果中间件已经结束（没有yield了），那么调用promise的resolve。</p>\n<p>否则的话把ret.value（就是下一个中间件对象），用co在包一层<code>toPromise.call(ctx, ret.value);</code></p>\n<pre class=\"prettyprint language-javascript\"><code>if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);\n</code></pre><p>上面是toPromise中的一段代码</p>\n<p>既然是用co又执行了一遍，那么co是返回promise的。所以返回的这个value就分别被监听了成功和失败的不同处理。</p>\n<pre class=\"prettyprint language-javascript\"><code>value.then(onFulfilled, onRejected);\n</code></pre><p>所以我们可以看到，如果第二个中间件里依然有<code>yield next</code>这样的语句，那么第三个中间件依然会被co包裹一层并运行.next方法，依次列推，这是一个递归的操作</p>\n<p>所以我们可以肯定的是，每一个中间件都被promise包裹着，直到有一天中间件中的逻辑运行完成了，那么会调用promise的resolve来告诉程序这个中间件执行完了。</p>\n<p>那么中间件执行完了之后，会触发<code>onFulfilled</code>，这个函数会执行.next方法。</p>\n<p>所以有一个非常重要的一点需要注意，<code>onFulfilled</code>这个函数非常重要，重要在哪里？？？重要在它执行的时间上。</p>\n<p><strong><code>onFulfilled</code>这个函数只在两种情况下被调用，一种是调用co的时候执行，还有一种是当前promise中的所有逻辑都执行完毕后执行</strong></p>\n<p>其实就这一句话就能说明koa的中间件为什么会回逆。</p>\n<p>回逆其实是有一个去和一个回的操作</p>\n<p>&lt;img src=“<a href=\"http://berwin.github.io/ppts/koa/img/koa-middleware3.png\">http://berwin.github.io/ppts/koa/img/koa-middleware3.png</a>” width=“250px”&gt;</p>\n<p>请求的时候经过一次中间件，响应的时候在经过一次中间件。</p>\n<p>而onFulfilled的两种被调用的情况正好和这个回逆的过程对应上。</p>\n<p>前方高能预警！！！</p>\n<p><strong>比如有3个中间件，当系统接收到请求的时候，会执行co，co会立刻执行onFulfilled来调用.next往下执行，将得到的返回结果（第二个中间件的generator对象，上面我们分析过）传到co中在执行一遍。以此类推，一直运行到最后一个yield，这个时候系统会等待中间件的执行结束，一旦最后一个中间件执行完毕，会立刻调用promise的resolve方法表示结束。（这个时候onFulfilled函数的第二个执行时机到了，这样就会出现一个现象，一个generator对象的yield只能被next一次，下次执行.next的时候从上一次停顿的yield处继续执行，所以现在当有一个中间件执行完毕后，在执行.next就会在前一个中间件的yield处继续执行）当最后一个中间件执行完毕后，触发promise的resolve，而别忘了，第二个中间件可是用then监听了成功和失败的不同处理方法，一旦第三个中间件触发成功，第二个中间件会立刻调用onFulfilled来执行.next，继续从第二个中间件上一次yield停顿处开始执行下面的代码，而第二个中间件的逻辑执行完毕后，同样会执行resolve表示成功，而这个时候第一个中间件正好也通过.then方法监听了第二个中间件的promise，也会立刻调用onFulfilled函数来执行.next方法，这样就会继续从第一个中间件上一次yield的停顿处继续执行下面的逻辑，以此类推。</strong></p>\n<p>这样就实现了中间件的回逆，通过递归从外到里执行一遍中间件，然后在通过promise+generator从里往外跳。</p>\n<p>所以如果我们在一个中间件中写好多yield，就可以看出关键所在，先通过递归从外往里（从第一个中间件运行到最后一个中间件）每次遇到yield next就会进入到下一个中间件执行，当运行到最后发现没有yield的时候，会跳回上一个中间件继续执行yield后面的，结果发现又有一个yield next，它会再次进入到下一个中间件，进入到下一个中间件后发现什么都没有，因为yield的特性（一个generator对象的yield只能被next一次，下次执行.next的时候从上一次停顿的yield处继续执行），所以便又一次跳入上一个中间件来执行。以此类推。</p>\n<p>我们试一下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var koa = require(&#x27;koa&#x27;);\nvar app = koa();\n\napp.use(function* f1(next) {\n  console.log(&#x27;f1: pre next&#x27;);\n  yield next;\n  console.log(&#x27;f1: post next&#x27;);\n  yield next;\n  console.log(&#x27;f1: fuck&#x27;);\n});\n\napp.use(function* f2(next) {\n  console.log(&#x27;  f2: pre next&#x27;);\n  yield next;\n  console.log(&#x27;  f2: post next&#x27;);\n  yield next;\n  console.log(&#x27;  f2: fuck&#x27;);\n});\n\napp.use(function* f3(next) {\n  console.log(&#x27;  f3: pre next&#x27;);\n  yield next;\n  console.log(&#x27;  f3: post next&#x27;);\n  yield next;\n  console.log(&#x27;  f3: fuck&#x27;);\n});\n\napp.use(function* (next) {\n  console.log(&#x27;hello world&#x27;)\n  this.body = &#x27;hello world&#x27;;\n});\n\n\napp.listen(3000);\n</code></pre><p>上面的代码打印的log是下面这样的</p>\n<pre class=\"prettyprint language-javascript\"><code>f1: pre next\n  f2: pre next\n  f3: pre next\nhello world\n  f3: post next\n  f3: fuck\n  f2: post next\n  f2: fuck\nf1: post next\nf1: fuck\n</code></pre><p>如果非要画一个图的话，我脑海中大概长这样</p>\n<p>&lt;img src=“<a href=\"http://berwin.github.io/ppts/koa/img/co.png\">http://berwin.github.io/ppts/koa/img/co.png</a>” width=“100%”&gt;</p>\n<p>其实刚刚那么一通复杂的逻辑下来，好多同学都会懵逼，那么我用白话文来说一下中间件的逻辑，大概是这样的</p>\n<p><strong>第一个中间件代码执行一半停在这了，触发了第二个中间件的执行，第二个中间件执行了一半停在这了，触发了第三个中间件的执行，然后，，，，，，第一个中间件等第二个中间件，第二个中间件等第三个中间件，，，，，，第三个中间件全部执行完毕，第二个中间件继续执行后续代码，第二个中间件代码全部执行完毕，执行第一个中间件后续代码，然后结束</strong></p>\n<p>用一张图表示大概是这样的。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/3739368/14908102/e58c340a-0e04-11e6-93ba-ac04e342ae7f.png\" alt=\"middleware\"></p>\n<p>为了方便理解，伪代码大概是下面这样</p>\n<pre class=\"prettyprint language-javascript\"><code>new Promise(function(resolve, reject) {\n  &#x2F;&#x2F; 我是中间件1\n  yield new Promise(function(resolve, reject) {\n    &#x2F;&#x2F; 我是中间件2\n    yield new Promise(function(resolve, reject) {\n      &#x2F;&#x2F; 我是中间件3\n      yield new Promise(function(resolve, reject) {\n        &#x2F;&#x2F; 我是body\n      });\n      &#x2F;&#x2F; 我是中间件3\n    });\n    &#x2F;&#x2F; 我是中间件2\n  });\n  &#x2F;&#x2F; 我是中间件1\n});\n</code></pre><p>这就是最核心的思想！！！</p>\n<h4>总结</h4>\n<p>简单总结一下，其实也很简单，只是第一次接触的同学可能暂时没有理解透彻。</p>\n<p>其实就是通过generator来暂停函数的执行逻辑来实现等待中间件的效果，通过监听promise来触发继续执行函数逻辑，所谓的回逆也不过就是同步执行了下一个中间件罢了。</p>\n<p>比如有几个中间件，mw1,mw2,mw3,mwn…</p>\n<p>站在mw1的角度上看，它是不需要关系mw2里面有没有mw3，它只需要关心mw2何时执行完毕即可，当mw2执行完毕mw1继续执行yield之后的代码逻辑。其实很简单，callback也是这个原理，当mw2执行完毕执行下callback，mw1是不需要关心mw2里面究竟是怎样运行的，只要知道mw2执行完会执行回调就行了。mw2也是同样的道理不需要关心mw3。</p>\n<p>到这里，关于koa我们就已经差不多都说完了。当然还有一些细节没有说，比如koa中的错误处理，但其实都是小问题啦，关于generator的错误处理部分弄明白了，自然就明白koa的错误处理是怎样的。这里就不在针对这些讲述了，一次写这么多确实有点累，或许后期会补充进来吧。。</p>\n<h2>两个重要技术点</h2>\n<p>最后，如果认真阅读下来的同学能感觉出来，koa中有两个最重要的地方，无论是使用上，还是思想上，这两个点都非常重要，koa也只有这两个概念</p>\n<ul>\n<li>Middleware - 中间件</li>\n<li>Context - 上下文</li>\n</ul>\n<p>最后说一些自己对koa的感觉，真他妈的是赏心悦目啊，真他妈的是优雅啊！！！每一行代码都浓缩了很多层含义，通过最少的代码实现最复杂的功能，对于我这种追求代码的极致优雅的人，看完koa之后，真的是感触良多，泪流满面啊。。。。</p>\n<p>ppt：<a href=\"http://berwin.github.io/ppts/koa/\">http://berwin.github.io/ppts/koa/</a></p>\n<p>转载请注明出处</p>\n<p>&lt;img src=“<a href=\"https://cloud.githubusercontent.com/assets/3739368/17135002/0c2d3eb0-5360-11e6-8c7d-5af47343303d.jpg\">https://cloud.githubusercontent.com/assets/3739368/17135002/0c2d3eb0-5360-11e6-8c7d-5af47343303d.jpg</a>” width=“320px”&gt;&lt;img src=“<a href=\"https://cloud.githubusercontent.com/assets/3739368/17135005/0e5e525a-5360-11e6-9233-a0cdfd1caead.jpg\">https://cloud.githubusercontent.com/assets/3739368/17135005/0e5e525a-5360-11e6-9233-a0cdfd1caead.jpg</a>” width=“320px”&gt;</p>\n</div>",
            "title": "深入浅出 Koa",
            "last_reply_at": "2017-12-21T00:53:40.156Z",
            "good": true,
            "top": false,
            "reply_count": 39,
            "visit_count": 16938,
            "create_at": "2016-03-14T09:47:21.178Z",
            "author": {
                "loginname": "berwin",
                "avatar_url": "https://avatars0.githubusercontent.com/u/3739368?v=4&s=120"
            }
        },
        {
            "id": "5a3a92ffd92f2f5b185ad090",
            "author_id": "590d7e623504ce1c2ac45912",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h2>什么是 webpack</h2>\n<p>   webpack 是德国开发者 Tobias Koppers 开发的<strong>模块加载器</strong>。</p>\n<p>  在 webpack 中所有的文件都将被当做模块使用。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有的这些模块打包成一个或多个 bundle。如图所示：\n<img src=\"http://images.cnblogs.com/cnblogs_com/hvkcode/966655/o_what-is-webpack.png\" alt=\"webpack能做什么\"></p>\n<h2>与 Gulp/Grunt 对比</h2>\n<p>  webpack 与 Gulp/Grunt 是没有对比性的,因为Gulp/Grunt是一种能够优化前端的开发流程的工具，而 webpack 是一种模块化的解决方案。不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。</p>\n<p>  Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。</p>\n<p><img src=\"http://images.cnblogs.com/cnblogs_com/hvkcode/966655/o_gulp-grunt.png\" alt=\"Grunt和Gulp工作图\"></p>\n<p>  webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p>\n<p><img src=\"http://images.cnblogs.com/cnblogs_com/hvkcode/966655/o_1031000-160bc667d3b6093a.png\" alt=\"webpack工作图\"></p>\n<h2>webpack的安装及使用 （<a href=\"https://github.com/SilenceHVK/learn-webpack/tree/master/demo1\">Demo1 Source</a>）</h2>\n<ol>\n<li>通过 npm  全局安装 webapck</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code>    $ npm install -g webpack\n</code></pre><ol>\n<li>创建项目并初始化 package.json 文件</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code>    $ mkdir demo1 &amp;&amp; cd demo1\n    $ npm init\n</code></pre><ol>\n<li>在项目中安装 webpack</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code>    $ npm install webpack --save-dev\n</code></pre><blockquote>\n<p>–save-dev 是开发时候依赖的东西，–save 是发布之后还依赖的东西</p>\n</blockquote>\n<ol>\n<li>\n<p>在项目中创建如下文件结构\n&lt;pre&gt;\n.<br>\n├── index.html  // 显示的网页\n├── main.js    // webpack 入口\n└── bundle.js // 通过 webpack 命令生成的文件，无需创建\n&lt;/pre&gt;</p>\n</li>\n<li>\n<p>通过命令对项目中依赖的js文件进行打包</p>\n</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code>    # webpack 要打包的 js 文件名  打包后生成的js文件名\n    $ webpack main.js bundle.js\n</code></pre><p>  在webpack命令后面还可以加入以下参数</p>\n<ul>\n<li><code>--watch</code> 实时打包</li>\n<li><code>--progress</code> 显示打包进度</li>\n<li><code>--display-modules</code> 显示打包的模块</li>\n<li><code>--display-reasons</code> 显示模块包含在输出中的原因</li>\n</ul>\n<p>  更多参数可以通过命令 <code>webpack --help</code> 查看</p>\n</div>",
            "title": "【Webpack】1.入门及简单使用",
            "last_reply_at": "2017-12-20T16:42:39.698Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 163,
            "create_at": "2017-12-20T16:42:39.698Z",
            "author": {
                "loginname": "SilenceHVK",
                "avatar_url": "https://avatars3.githubusercontent.com/u/12862565?v=4&s=120"
            }
        },
        {
            "id": "5a3a7ef6d92f2f5b185ad08e",
            "author_id": "540bc0e882a3d121496f15a3",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>var callfile = require(‘child_process’);\ncallfile.execFile(’…/git_indexData.sh’,function(err,stdout,stderr){\n\t\t\t\tif(err){\n\t\t\t\t\tconsole.log(err);\n\t\t\t\t}else if(stdout){\n\t\t\t\t\tconsole.log(stdout);\n\t\t\t\t}else if(stderr){\n\t\t\t\t\tconsole.log(stderr);\n\t\t\t\t}\n\t\t\t});\n<img src=\"//dn-cnode.qbox.me/FixdzJ9tT7NFuwug3cpr88fdYFBi\" alt=\"8PTL0(8C0P(_7AH$9K$@ES5.png\"></p>\n<p>git_indexData.sh 文件在当前代码文件的上一个目录</p>\n<p>nodejs调用sh脚本，帮忙看一下</p>\n</div>",
            "title": "在线等 child_process.execFile 帮忙看下，没调出来",
            "last_reply_at": "2017-12-20T15:28:55.432Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 121,
            "create_at": "2017-12-20T15:17:10.223Z",
            "author": {
                "loginname": "manymore13",
                "avatar_url": "https://avatars2.githubusercontent.com/u/7828627?v=4&s=120"
            }
        },
        {
            "id": "5a3a2da58230827a182938ef",
            "author_id": "5a03e7bbad77fa2004549172",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>百度了半天开通了GitHub pages\n但是怎么弄进去的还是README.md文件\n请问该怎么弄，才能访问到我部署的build文件？</p>\n</div>",
            "title": "github怎么部署静态页面？",
            "last_reply_at": "2017-12-20T12:31:44.664Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 180,
            "create_at": "2017-12-20T09:30:13.170Z",
            "author": {
                "loginname": "fruit-memory",
                "avatar_url": "https://avatars1.githubusercontent.com/u/29981970?v=4&s=120"
            }
        },
        {
            "id": "5a3a28929807389a1809f582",
            "author_id": "5a308492f15b4f306d2f02c9",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>请问　react 怎么引入阿里字体图标</p>\n</div>",
            "title": "react 怎么引入阿里字体图标？",
            "last_reply_at": "2017-12-20T12:29:22.878Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 171,
            "create_at": "2017-12-20T09:08:34.619Z",
            "author": {
                "loginname": "zsrzsrzsr-zsr",
                "avatar_url": "https://avatars1.githubusercontent.com/u/33851847?v=4&s=120"
            }
        },
        {
            "id": "5a311f729807389a1809f37a",
            "author_id": "57b99bc2dcaeb5d932db220a",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h1>Web性能</h1>\n<p>从底层计算机网络协议到应用层各个方面去理解Web性能。目前项目处于刚开始阶段，欢迎对性能优化感兴趣的同学共同参与总结！</p>\n<p>Github: <a href=\"https://github.com/laoqiren/web-performance\">https://github.com/laoqiren/web-performance</a></p>\n<h2>目录</h2>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/README.md\">网页渲染原理</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">渲染过程</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.md\">资源加载顺序</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">浏览器优化策略</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/repaint%E4%B8%8Ereflow.md\">repaint与reflow</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/tree/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F\">带宽与延迟</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%BC%80%E5%A7%8B.md\">从输入URL开始</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F.md\">带宽与延迟</a></li>\n<li>TCP协议细节</li>\n<li>HTTP 1.x性能</li>\n<li>针对性优化</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/README.md\">缓存机制</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.md\">首部字段</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA.md\">浏览器行为</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E4%BC%98%E5%8C%96.md\">优化</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/tree/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90\">静态资源</a>\n<ul>\n<li>减少请求</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9.md\">资源压缩</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96.md\">图片资源优化</a></li>\n<li>Webpack</li>\n<li>CDN</li>\n</ul>\n</li>\n<li>Virtual DOM\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E8%99%9A%E6%8B%9FDOM/React%E5%9F%BA%E7%A1%80.md\">React基础</a></li>\n<li>实现</li>\n<li>diff算法</li>\n<li>性能考虑</li>\n</ul>\n</li>\n<li>SPA与SSR\n<ul>\n<li>SPA问题</li>\n<li>服务端渲染</li>\n<li>同构应用</li>\n<li>性能问题</li>\n</ul>\n</li>\n<li>HTTP2\n<ul>\n<li>新特性概览</li>\n<li>性能提升</li>\n<li>工程实践</li>\n</ul>\n</li>\n<li>HTTPS性能影响\n<ul>\n<li>TLS原理</li>\n<li>性能影响</li>\n</ul>\n</li>\n<li>高性能JavaScript\n<ul>\n<li>V8与JIT</li>\n<li>内存泄露</li>\n<li>GC机制</li>\n<li>算法与流程</li>\n<li>Web worker</li>\n</ul>\n</li>\n<li>WebAssembly</li>\n<li>PWA与离线应用</li>\n<li>即时运用与P2P</li>\n<li>Node.js性能优化</li>\n<li>集群与负载均衡</li>\n<li>数据库相关</li>\n<li>性能测试\n<ul>\n<li>Chrome开发者工具</li>\n<li>benchmark</li>\n<li>压力测试</li>\n</ul>\n</li>\n</ul>\n<h2>引用说明</h2>\n<p>此项目会引用许多其他文章书籍的图片或部分内容，我会尽量都加以注明，如果有部分遗漏以致于侵犯到您的版权，烦请联系我修改！此项目旨在整理零碎的知识和实践方案，方便交流学习，请勿用于商业用途。</p>\n<h2>参与贡献</h2>\n<ul>\n<li>提想法和建议</li>\n<li>纠错完善</li>\n<li>增加新章节或内容</li>\n</ul>\n</div>",
            "title": "性能优化知识与实践整理",
            "last_reply_at": "2017-12-20T12:29:17.532Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 747,
            "create_at": "2017-12-13T12:39:14.755Z",
            "author": {
                "loginname": "laoqiren",
                "avatar_url": "https://avatars2.githubusercontent.com/u/16136702?v=4&s=120"
            }
        },
        {
            "id": "5a2e6e79d92f2f5b185acd98",
            "author_id": "50b5bc5d637ffa4155091236",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>如果路由在后端，那是不是页面层都要从后台取，这样好象就是以前的模式 不能算前后台分离了</p>\n</div>",
            "title": "前后台分离是不要必须要在前端实现路由？",
            "last_reply_at": "2017-12-20T12:07:00.114Z",
            "good": false,
            "top": false,
            "reply_count": 14,
            "visit_count": 826,
            "create_at": "2017-12-11T11:39:37.691Z",
            "author": {
                "loginname": "yakczh",
                "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
            }
        },
        {
            "id": "5a379f5a8230827a18293831",
            "author_id": "5a37639a8230827a18293810",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FqJWXCMOyBzBZusR38eFJ1JYwaFF\" alt=\"newrelease.png\"><img src=\"//dn-cnode.qbox.me/FrY299Kx_DfPkRZV734y8_nRTyki\" alt=\"model.png\"><img src=\"//dn-cnode.qbox.me/FqQYcUH3Ak5MTm4mkL-iMchaxunshy5KH3WK\" alt=\"32.png\">查询数据为空啊</p>\n</div>",
            "title": "为什么mongoose populate 查不到数据？？？",
            "last_reply_at": "2017-12-20T10:54:06.382Z",
            "good": false,
            "top": false,
            "reply_count": 10,
            "visit_count": 369,
            "create_at": "2017-12-18T10:58:34.006Z",
            "author": {
                "loginname": "daohaoma",
                "avatar_url": "https://avatars2.githubusercontent.com/u/30073118?v=4&s=120"
            }
        },
        {
            "id": "559bd1b91e5c761761468884",
            "author_id": "51ed5627f4963ade0ea60395",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h2>前言</h2>\n<p><img src=\"//dn-cnode.qbox.me/FofaKJsQyyIBzmwofpcJKTeh1UEQ\" alt=\"noder-Icon.png\"></p>\n<p>业余时间写的，目前只有IOS版本(安卓版本等React-Native发布安卓版本后会跟进)。\n目前处于开发阶段，bug很多，还有各种事情要做。各位坛友可以clone下来跑在iphone上试试。\n目前代码有点乱，各位客官先看着。哈哈。\n有iPhone的同学可以在手机上安一个（方法我后面会提到），然后没事就可以用这个暂且回帖，并顺便帮忙测试嘛。</p>\n<h2>下载地址：</h2>\n<p><strong><em>Android：</em></strong> <a href=\"https://www.pgyer.com/pEFf\">https://www.pgyer.com/pEFf</a></p>\n<h2>在线演示</h2>\n<p><strong>WEB在线演示</strong>：</p>\n<p><a href=\"https://rnplay.org/apps/_2y0Dw\">https://rnplay.org/apps/_2y0Dw</a></p>\n<p><strong>IOS演示</strong>：</p>\n<p>下载<a href=\"https://itunes.apple.com/us/app/react-native-playground/id1002032944\">React Native Playground</a>，然后在里面找到<strong>noder</strong>，点击运行就可以。</p>\n<p>或者直接用<a href=\"https://itunes.apple.com/us/app/react-native-playground/id1002032944\">React Native Playground</a>来扫描以下二维码：</p>\n<p><img src=\"https://chart.googleapis.com/chart?cht=qr&amp;chl=%7B%22bundle_path%22%3A%20%22%2Fjs%2F_2y0Dw%2Findex.ios.bundle%22%2C%20%22module_name%22%3A%20%22noder%22%7D&amp;chs=250x250\" alt></p>\n<h2>顺便友情招聘</h2>\n<p><a href=\"https://cnodejs.org/topic/55a77e2f93ce02cd25985916\">光音网络  ----  老外当CTO，自由开放的文化</a></p>\n<h2>仓库地址</h2>\n<p><a href=\"https://github.com/soliury/noder-react-native\">https://github.com/soliury/noder-react-native</a></p>\n<h2>功能演示</h2>\n<p><img src=\"http://7lrzfj.com1.z0.glb.clouddn.com/soliurynoder-v1.0.0.gif\" alt></p>\n<h2>目前已有功能</h2>\n<ul>\n<li>回帖</li>\n<li>查看帖子</li>\n<li>查看用户信息</li>\n<li>查看消息</li>\n<li>点赞</li>\n<li>发帖</li>\n</ul>\n<h2>未实现的功能</h2>\n<ul>\n<li>根据点赞的个数置顶回帖</li>\n<li>推送</li>\n</ul>\n<h2>TODO LIST</h2>\n<h3>V1.0.0</h3>\n<ul>\n<li>修复各种小bugs</li>\n<li>重构代码（现在的代码真的很乱，很乱）</li>\n<li>添加测试</li>\n<li>上线到app Store</li>\n</ul>\n<h3>V2.0.0</h3>\n<ul>\n<li>添加推送</li>\n<li>添加github功能（例如：预览github页面，绑定github，start项目，fork项目）</li>\n</ul>\n<h2>试用</h2>\n<pre class=\"prettyprint\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;soliury&#x2F;noder-react-native.git\nnpm install\n</code></pre><p>然后在Xcode中点击运行。</p>\n<p>想要跑在iphone上，需要运行：</p>\n<pre class=\"prettyprint\"><code>\tgulp replace\n</code></pre><p>这样可以自动将js的获取地址改为电脑ip</p>\n<p>然后按照react-native<a href=\"http://facebook.github.io/react-native/docs/runningondevice.html#content\">官方文档</a>设置即可运行在手机上。</p>\n<p>当然我现在更加希望坛友如果有Iphone，可以跑一个离线build版本，这样地铁上也可以用一用，然后还可以顺便帮忙测试一下用起来如何。</p>\n<h3>如何做</h3>\n<ul>\n<li>打开<code>iOS/AppDelegate.m</code></li>\n<li>将<code>jsCodeLocation = [[NSBundle mainBundle]</code>这行代码的注释去掉</li>\n<li>运行<code>react-native bundle</code></li>\n</ul>\n<h3>出现错误可以尝试以下解决办法</h3>\n<ul>\n<li>重新编译所有的依赖的库（这里指oc的库，不是js）</li>\n</ul>\n<h2>联系方式</h2>\n<p><strong>微信:</strong> lingyong1992\n<strong>邮箱:</strong> <a href=\"mailto:hi@lingyong.me\">hi@lingyong.me</a></p>\n<p>React-Native是一个新东西，如果你很感兴趣，欢迎探讨。当然，如果你对RN比较了解，也希望一起维护<a href=\"https://github.com/soliury/noder-react-native\">noder</a>，请联系我。</p>\n</div>",
            "title": "React-Native 客户端【v1.0.0-alpha2】【安卓已发布】【最后更新：2016.4.14】",
            "last_reply_at": "2017-12-20T10:37:15.639Z",
            "good": true,
            "top": false,
            "reply_count": 151,
            "visit_count": 13476,
            "create_at": "2015-07-07T13:18:49.805Z",
            "author": {
                "loginname": "soliury",
                "avatar_url": "https://avatars0.githubusercontent.com/u/5032079?v=4&s=120"
            }
        },
        {
            "id": "5a39e8a7d92f2f5b185ad049",
            "author_id": "5a38adeb8230827a1829386e",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FtP-GVJkfvjOmds9ZBGJvo40-XqW\" alt=\"选区_012.png\"></p>\n</div>",
            "title": "node新手, 使用finalhandler 时报错",
            "last_reply_at": "2017-12-20T09:54:54.036Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 178,
            "create_at": "2017-12-20T04:35:51.611Z",
            "author": {
                "loginname": "gmw-zjw",
                "avatar_url": "https://avatars2.githubusercontent.com/u/25763661?v=4&s=120"
            }
        },
        {
            "id": "5a3a06e3d92f2f5b185ad05c",
            "author_id": "54bc7fde0049cbcc5994c51f",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p><a href=\"/user/alsotang\">@alsotang</a></p>\n</div>",
            "title": "cnode广告投放联系谁？",
            "last_reply_at": "2017-12-20T08:44:11.546Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 283,
            "create_at": "2017-12-20T06:44:51.780Z",
            "author": {
                "loginname": "einsqing",
                "avatar_url": "https://avatars3.githubusercontent.com/u/7685948?v=4&s=120"
            }
        },
        {
            "id": "5a331fd6d1536726354b7d9b",
            "author_id": "5a31effb8230827a182936ff",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h3>免责声明</h3>\n<p>首发公众号【一名打字员】\n本文记录了一名打字员的日常生活一天。仅仅代表本猿一名打字员的日常生活，不代表其它打字员。如有雷同，那么恭喜，你和本猿一样生活充满着尴尬。</p>\n<h3>2017-11-23</h3>\n<ul>\n<li>8:10-9:00 起床上班</li>\n</ul>\n<p>昨晚睡前看了一集《极限挑战》，宿“剧”未醒，感觉整个人疲惫不堪难以醒来。没办法，为了生活，给了自己两巴掌（当然是脑补的）起床洗漱，公司9:00上班，换好衣服拿了一瓶红枣味酸奶和一小包三明治出门，到公司刚好9点。</p>\n<ul>\n<li>9:00-9:30 瞎逛各大论坛\n首先点开segmentfault，看看草稿箱里还有几篇存货，然后点开首页，看看热门问题和文章。自从写了几篇前端之后，感觉好像我的热门里面出现了许多以前都没有的推荐，难道segmentfault推荐算法也改进了（疑问句）。为了方便清楚的描述所逛的内容，本猿爬取了首页热门推荐的内容，并简单处理了一下，如下图所示：</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/FmtgsgySg7TCerXmygMF4uQnNYC4\" alt=\"untitled1.png\"></p>\n<p>当然为了博取小伙伴的眼球，我还换了一种风格。</p>\n<p><img src=\"//dn-cnode.qbox.me/FrH958Ni75Z8jgcE_w7_hGzXDCTl\" alt=\"untitled2.png\"></p>\n<p>是不是远远的看去像一位欲迎还拒的小姑凉（此处脑补n个字）</p>\n<ul>\n<li>\n<p>9:30-12:00 日常写BUG\n这段时间处于机械编程式劳动，基本上是处于收到需求，解析需求，写BUG。或者是收到BUG，改BUG,写BUG。\n中间程序编译的过渡阶段（这个阶段有的时候异常漫长，懂的猿请点个赞谢谢），通常会与各大企鹅群里的小伙伴进行撕逼，就某一个话题或者某一个知识点或者是不知道是啥东西的情况下进行激烈的讨论，然后午饭时间就到了。</p>\n</li>\n<li>\n<p>12:00-13:00 午饭时间\n有的时候点个外卖，有的时候去外面吃一个重庆小面什么的。千篇一律，没有任何波澜。</p>\n</li>\n<li>\n<p>13:00-14:00 笔记和博客整理\n刚吃完饭休息了一会儿，整理一下笔记内容，把一些知识点整理一下放在博客中。当然笔记里面的内容实在是杂乱无章，各种语言如C、C++、Python、Node、Vue、React、Java、Ruby、C#的小知识，大都是做项目时碰到了，然后随手粘贴复制到笔记本中，还有各种心情，奇怪（手动尴尬）。</p>\n</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/FkSSetgos67ZkpSzNDgVFioSnG6U\" alt=\"untitled3.png\"></p>\n<ul>\n<li>\n<p>14:00-17:00 继续写BUG\n写了一会儿博客，发现新的BUG、新的需求又来了，又得不停的改BUG写BUG了，另外这段时间里又会产生无数次的撕逼。</p>\n</li>\n<li>\n<p>17:00-18:00 忙里偷闲\n手头的工作忙的差不多了，偷偷的逛逛知乎并把整理好的文章粘贴到公众号上发布。本来准备抓一下知乎自己日常浏览的动态，写完模拟登录（知乎需要登录，不然很多地方的内容无法抓取）然后抓了一下首页推送内容，做了一个分词权重的时候，发现结果有很多“少儿不宜”的关键字和图片（这里也许和关注的大V有关系），就不展示了。</p>\n</li>\n<li>\n<p>18:00-19:30 日常加班\n这段时间公司其它部门该下班的都下班了，就剩技术部在坚守岗位，没办法，还有太多的bug和改不完的需求在等着我们，遇到上线，还要再晚一点，所以说打字员是门苦力活没毛病儿。</p>\n</li>\n<li>\n<p>19:30-20:30 晚饭回家\n解决一下晚饭，然后背上行囊，扛着枪举着炮一路走去回家的方向。这个时候的上海是让我觉得最舒服的，一个人走着，也没人认识你，想想今天又过了一天，感觉啥也没干，想起没修完的BUG…啥，当我没想起来…\n回到家刚好8:30左右。</p>\n</li>\n<li>\n<p>20:30-21:00 洗漱\n写了一天BUG了，回到家只想先好好的洗个澡，沐浴更衣一下，然后打把游戏或者看个电视什么的。</p>\n</li>\n<li>\n<p>21:00-23:30 游戏睡觉\n打开某网络播放器，刷了一圈没有看到好看的剧。就叫上室友一起手游，最近一个网易手游在公测，具体和“吃鸡”差不多，和室友玩的也是昏天黑地，比如说正在与三人徒手决斗的时候，室友突然驾驶一辆破面包车来单独撞死了我。又或者是说好的掩护我，自己一个人偷偷跑掉。就是这样的室友我依然没有嫌弃他，最后临睡前带着他吃了一把“鸡”。\n关上手机，刚好23：30，躺下想了想自己还没赚到的一百万和还没有升职加薪，带着一股浓浓的忧愁翻了个身睡觉。</p>\n</li>\n</ul>\n<h3>自我评价</h3>\n<p>这就是本猿一个普普通通的打字员的日常，平常除了写写BUG，追追番和打游戏之外，几乎找不到其它的乐趣。每天晚上都骂这个世界让自己活的这么窝囊，要不甘平凡，第二天早上却继续拖着疲惫不堪的身体又开始继续碌碌无为的一天。总想着自己可以改变世界，但是却混不知自己正在一点一点被时间改变。</p>\n<blockquote>\n<p>像我这样优秀的人，本该灿烂过一生，怎么二十多年来还在人海里浮沉。\n像我这么碌碌无为的人，你还见过多少人。</p>\n</blockquote>\n</div>",
            "title": "一名打字员的日常",
            "last_reply_at": "2017-12-20T08:20:19.861Z",
            "good": false,
            "top": false,
            "reply_count": 26,
            "visit_count": 1001,
            "create_at": "2017-12-15T01:05:26.582Z",
            "author": {
                "loginname": "wslongchen",
                "avatar_url": "https://avatars1.githubusercontent.com/u/6868861?v=4&s=120"
            }
        },
        {
            "id": "5a3a1d298230827a182938df",
            "author_id": "5a31effb8230827a182936ff",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h1>前言</h1>\n<p>本文首发公众号 【一名打字员】</p>\n<p>网上墙内关于这方面的文章真的很少，本猿也是通过官网一点一点学习，希望能够帮助到大家。<a href=\"http://www.express-gateway.io\">express-gateway官网</a></p>\n<h1>安装</h1>\n<ul>\n<li>安装Express Gateway</li>\n</ul>\n<pre class=\"prettyprint\"><code>npm install -g express-gateway\n</code></pre><ul>\n<li>创建一个项目</li>\n</ul>\n<pre class=\"prettyprint\"><code>eg gateway create\n</code></pre><ul>\n<li>初始一些基本信息配置</li>\n</ul>\n<pre class=\"prettyprint\"><code>eg gateway create\n ? What is the name of your Express Gateway? my-gateway\n ? Where would you like to install your Express Gateway? my-gateway\n ? What type of Express Gateway do you want to create? (Use arrow keys)\n ❯ Getting Started with Express Gateway\n   Basic (default pipeline with proxy)\n</code></pre><ul>\n<li>启动</li>\n</ul>\n<pre class=\"prettyprint\"><code>cd my-gateway &amp;&amp; npm start\n</code></pre><p>这样基本的一个项目就已经成型了。</p>\n<h1>使用方法</h1>\n<h3>指定服务并把API暴露出来（API提供者）</h3>\n<ul>\n<li>第一步</li>\n</ul>\n<p>我们会发现，项目中已经把代理了一个现有的服务 <code>https://httpbin.org/ip</code> ,并对其进行管理。它提供了一个json的输出，我们可以展示一下快速网关的功能。访问 <code>https://httpbin.org/ip</code> ，会有以下输出：</p>\n<pre class=\"prettyprint\"><code>{\n  &quot;origin&quot;: &quot;218.80.1.67&quot;  #自己的IP\n}\n</code></pre><ul>\n<li>第二步</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fn-CplBsRx5jhk3BliJ7kFUe2d3i\" alt=\"image.png\"></p>\n<p>该服务被指定为快速网关中默认管道的服务端，网关有自己的代理策略，之前的 <code>https://httpbin.org/ip</code> 则是网关设置的一个服务请求。配置在config目录下的 <code>gateway.config.yml</code> 文件。</p>\n<pre class=\"prettyprint\"><code>http:\n  port: 8080\nadmin:\n  port: 9876\n  hostname: localhost\napiEndpoints:\n  api:\n    host: localhost\n    paths: &#x27;&#x2F;ip&#x27;\nserviceEndpoints:\n  httpbin:\n    url: &#x27;https:&#x2F;&#x2F;httpbin.org&#x27;\npolicies:\n  - basic-auth\n  - cors\n  - expression\n  - key-auth\n  - log\n  - oauth2\n  - proxy\n  - rate-limit\npipelines:\n  default:\n    apiEndpoints:\n      - api\n    policies:\n    # Uncomment &#96;key-auth:&#96; when instructed to in the Getting Started guide.\n    # - key-auth:\n      - proxy:\n          - action:\n              serviceEndpoint: httpbin \n              changeOrigin: true\n</code></pre><p>可以看到这里配置了一个默认的服务端点，网关会在默认代理策略中找到 <code>httmbin</code> 。</p>\n<ul>\n<li>第三步</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fm07_JFmJeNxZvd-3o4PidwbMcTG\" alt=\"image.png\"></p>\n<p>接下来我们需要让 <code>httpbin</code> 服务作为一个API端点穿过网关，并当这个API公开时，可以被外部所访问。\n在上面的 <code>gateway.config.yml</code> 配置文件中，我们找到 <code>apiEndpoints</code> 这个设置，其中有一个 <code>api</code> 的设置项。</p>\n<pre class=\"prettyprint\"><code>apiEndpoints:\n  api:\n    host: localhost\n    paths: &#x27;&#x2F;ip&#x27;\n</code></pre><p>PS:默认情况下，API请求路径将被代理策略挂在服务端点中。</p>\n<ul>\n<li>第四步</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fp3KUo3SIFb1nl0WGSWbzBIfiLGZ\" alt=\"image.png\"></p>\n<p>现在我们就可以通过网关来访问API了，访问 <code>http://localhost:8080/ip</code> 。</p>\n<h3>创建API消费者</h3>\n<p>方便管理API，我们将允许使用API的授权用户称为“消费者”。如用户的创建，进入项目根目录，创建：</p>\n<pre class=\"prettyprint\"><code>eg users create\n Enter username [required]: mrpan\n Enter firstname [required]: coder\n Enter lastname [required]: coder\n Enter email: 1049058427@qq.com\n Enter redirectUri: www.baidu.com\n√ Created 892775c8-80c5-480e-b596-6cb3133691f2\n\n &quot;firstname&quot;: &quot;coder&quot;,\n &quot;lastname&quot;: &quot;coder&quot;,\n &quot;email&quot;: &quot;1049058427@qq.com&quot;,\n &quot;redirectUri&quot;: &quot;www.baidu.com&quot;,\n &quot;isActive&quot;: true,\n &quot;username&quot;: &quot;mrpan&quot;,\n &quot;id&quot;: &quot;892775c8-80c5-480e-b596-6cb3133691f2&quot;,\n &quot;createdAt&quot;: &quot;Sat Dec 16 2017 13:21:13 GMT+0800 (中国标准时间)&quot;,\n &quot;updatedAt&quot;: &quot;Sat Dec 16 2017 13:21:13 GMT+0800 (中国标准时间)&quot;\n\n</code></pre><h3>API权限认证</h3>\n<ul>\n<li>第一步</li>\n</ul>\n<p>现在我们的API是公开的，没有进行权限的控制，所以任何人都可以对它进行访问。我们现在用密钥授权对它进行保护，首先必须要将这个授权策略加入在配置文件 <code>gateway.config.yml</code> 中。</p>\n<pre class=\"prettyprint\"><code>pipelines:\n  - name: getting-started\n    apiEndpoints:\n      - api\n    policies:\n      - key-auth:\n      - proxy:\n        - action:\n          serviceEndpoint: httpbin\n          changeOrigin: true\n</code></pre><ul>\n<li>第二步</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fq1c17TNvsTnCR-MYVbVSTIJlzMa\" alt=\"image.png\"></p>\n<p>将密钥分给上面的用户 <code>mrpan</code></p>\n<pre class=\"prettyprint\"><code>eg credentials create -c mrpan -t key-auth -q\n10b9Yaalb982DreBukZvGf:3A2bhd1xzqwAvNWX0QfjD5\n</code></pre><p>PS：上面的-q选项是将输出限制为api的key，便于粘贴复制。</p>\n<ul>\n<li>第三步</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/FvVF88hdNXcic6yh0fScZS9Xefpl\" alt=\"image.png\"></p>\n<p>再次访问 <code>http://localhost:8080/ip</code> ，这个时候便不会打印结果了，只会打印出 <code>Unauthorized</code> 。</p>\n<ul>\n<li>第四步</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/FsXaQZQhpuhvD7RkZ0xA7FIruU34\" alt=\"image.png\"></p>\n<p>我们在访问的时候把key加上。这样，就能继续使用API了。</p>\n<p>到这里，网关的基本使用也就差不多了，大家可以梳理一下在自己的系统中进行扩展。</p>\n<h1>结语</h1>\n<p>现在大多大型网站架构都采用了微服务的模式，把系统拆分成一个一个的微服务，服务层可能会使用java或者使用其它语言编写，毕竟有Netflix这样的先例，成功的使用Node.js API网关及其JAVA后端来支持广泛的客户端。</p>\n</div>",
            "title": "入门到放弃node系列之express-gateway网关",
            "last_reply_at": "2017-12-20T08:19:53.185Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 195,
            "create_at": "2017-12-20T08:19:53.185Z",
            "author": {
                "loginname": "wslongchen",
                "avatar_url": "https://avatars1.githubusercontent.com/u/6868861?v=4&s=120"
            }
        },
        {
            "id": "5a38d530d1536726354b7f0d",
            "author_id": "57d216e13d3520a5387c2b53",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>这个ctx.state里面的loginbean<img src=\"//dn-cnode.qbox.me/FgeMBBGLiIi15XHXGKS8dvtMVUia\" alt=\"111111.png\"></p>\n<p>这个是在view层里面的loginbean 获取不到<img src=\"//dn-cnode.qbox.me/FlDM6t6O_ZZ0kib8lvuF5DjgxtD-\" alt=\"2222222.png\"></p>\n<p>这个是报错信息 说loginbean找不到<img src=\"//dn-cnode.qbox.me/FmSX2S3X5fi-ZP-spj2WF_R-o6xs\" alt=\"333333.png\"></p>\n</div>",
            "title": "大家好 有人用koa2框架吗？ 我在view层里面获取不到ctx.state的值是怎么回事",
            "last_reply_at": "2017-12-20T07:45:37.867Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 318,
            "create_at": "2017-12-19T09:00:32.770Z",
            "author": {
                "loginname": "a69694510",
                "avatar_url": "https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"
            }
        },
        {
            "id": "5a3a121f8230827a182938da",
            "author_id": "57637029c13e1e492222bd2d",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h2>背景</h2>\n<p>越来越多的应用基于前后端分离构建，后端提供数据接口，前端调用接口返回 json 数据渲染到 UI，这个时候保证后端接口数据正确性变的愈来愈重要，接口测试就是来解决这个问题。很多团队，接口测试就是手动运行接口，肉眼比对接口返回的数据，这样的操作流程效率低下，容易出错。使用 YApi 只需要在可视化 GUI 下，配置下每个接口的入参和对 RESPONSE 断言，即可实现对接口的自动化测试，大大提升了接口测试的效率。</p>\n<h2>准备工作</h2>\n<p>如果您还未部署 yapi 接口管理平台，可先去<a href=\"http://yapi.demo.qunar.com\">示例站点</a>试用。</p>\n<p>在创建完项目和接口后，需要进入到测试集页面，导入需要测试的接口。</p>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/006tCP9Lly1fmn93aa9j0j30gq09w3z9.jpg\" alt=\"import-api\"></p>\n<h2>基础概念</h2>\n<p>需要学习的基础概念主要包含测试集、Pre-Script 、Test-Script 三方面。</p>\n<h3>测试集</h3>\n<p>在平时的开发过程中，经常遇到的一个问题是每次调试接口都需要重新填写参数，YApi测试集能够保存之前填写的参数，方便下次的调试。每个的请求参数还可以通过前面已请求的接口数据读取，或填写mock随机字符串，通过设置断言脚本验证返回数据的正确性。</p>\n<p><img src=\"https://yapi.qunar.com/images/usage/case-list.gif\" alt=\"case\"></p>\n<h3>Pre-Script</h3>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/006tCP9Lly1fml6saq8dlj31zs0q8dj6.jpg\" alt=\"pre\"></p>\n<p>Pre-Script 包括请求参数处理脚本和响应数据处理脚本两部分。通过自定义 js 脚本方式改变请求的参数和返回的 response 数据。他的使用场景如下：</p>\n<ul>\n<li>接口请求参数需要加密及返回 response 解密</li>\n<li>接口请求参数需要添加计算 token</li>\n</ul>\n<h4>请求参数处理脚本示例</h4>\n<p>以 jquery ajax 为例，假设当前的请求参数是</p>\n<pre class=\"prettyprint\"><code>{\n  url: &#x27;&#x2F;api&#x2F;user?id=1&#x27;,\n  method: &#x27;POST&#x27;,\n  headers: {\n    xxx: &#x27;xxx&#x27;\n  },\n  data: {\n    type: 1\n  }\n}\n</code></pre><p>那么公共变量 context 包含以下属性：</p>\n<pre class=\"prettyprint\"><code>context = {\n  pathname: &#x27;&#x2F;api&#x2F;user&#x27;,\n  query: {\n    id: 1\n  },\n  requestHeader: {\n    xxx: &#x27;xxx&#x27;\n  },\n  method: &#x27;POST&#x27;,\n  requestBody: {\n    type:1\n  }\n}\n</code></pre><p>假设我们需要在 url 增加一个 token 参数，可以写如下自定义脚本：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tCP9Lly1fmkxnepjujj31e008ywfk.jpg\" alt></p>\n<h4>返回数据处理脚本示例</h4>\n<p>在上面的示例请求完成后，假设返回 responseBody={a:1},公共变量 context 包含以下属性：</p>\n<pre class=\"prettyprint\"><code>context = {\n  pathname: &#x27;&#x2F;api&#x2F;user&#x27;,\n  query: {\n    id: 1\n  },\n  requestHeader: {\n    xxx: &#x27;xxx&#x27;\n  },\n  method: &#x27;POST&#x27;,\n  requestBody: {\n    type:1\n  },\n  responseData: {\n    a:1\n  },\n  responseHeader: {\n    content-type: &#x27;application&#x2F;json&#x27;\n    ...\n  }\n}\n</code></pre><p>假设我们需要修改响应数据 responseBody a 的值为 2，可以填写如下自定义脚本：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tCP9Lly1fmkxoj7182j30wq07ut96.jpg\" alt></p>\n<h3>Test-Script (测试脚本)</h3>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tCP9Lly1fmkxresi1zj31nw0m6tcj.jpg\" alt></p>\n<p>通过自定义脚本断言接口参数或返回 response 数据，在接口用例页面点击 Test 编辑。</p>\n<h4>支持的公共变量</h4>\n<h5>1.assert</h5>\n<ul>\n<li>\n<p>assert(value)</p>\n<p>判断 value 是否为 truth, 例如 assert(1) 通过， assert(0) 不通过，只要 value 不是 null, 0, false等值验证通过</p>\n</li>\n<li>\n<p>assert.equal(actual, expected)</p>\n<p>判断 actual 是否等于 expected，例如 assert(1, 1)通过</p>\n</li>\n<li>\n<p>assert.notEqual(actual, expected)</p>\n<p>判断 actual 是否不等于 expected</p>\n</li>\n<li>\n<p>assert.deepEqual(actual, expected)</p>\n<p>假设： actual = {a:1} 是一个对象，即便 expected = {a:1}，如果使用 assert.equal 可能也是不相等的，因为在 js 引用的只是对象的一个指针，需要使用 assert.deepEqual 比较两个对象是否相等</p>\n</li>\n<li>\n<p>assert.notDeepEaual(actual, expected)</p>\n<p>深度比较两个对象是否不相等</p>\n</li>\n</ul>\n<h5>2.status</h5>\n<p>http 状态码</p>\n<h5>3.params</h5>\n<p>http request params, 合并了 query 和 body</p>\n<h5>4.body</h5>\n<p>返回 response body</p>\n<h5>5.header</h5>\n<p>返回 response header</p>\n<h5>6.records</h5>\n<p>记录的 http 请求信息，假设需要获取 key 为 555 的接口参数或者响应数据，可通过 records[555].params 或 records[555].body 获取</p>\n<h5>7.log</h5>\n<p>log（message） 函数,调试时使用，log 信息仅仅在断言失败后打印</p>\n<h4>示例</h4>\n<pre class=\"prettyprint\"><code>assert.equal(body.errcode, 0)\nassert.equal(body.data.group_name, &#x27;testGroup&#x27;)\nassert.equal(status, 200)\n</code></pre><h2>开始测试</h2>\n<h3>第一步：配置参数</h3>\n<p>YApi 除了支持常量字符串外，还支持 mock 随机字符串和变量字符串。</p>\n<h3>Mock参数</h3>\n<p>Mock 参数每次请求都会生成随机字符串,支持 mockjs 所有占位符</p>\n<p><img src=\"https://yapi.ymfe.org/images/usage/case-edit.jpg\" alt></p>\n<h4>变量参数</h4>\n<p>YApi 提供了强大的变量参数功能，你可以在测试的时候使用前面接口的 <code>参数</code> 或 <code>返回值</code> 作为 <code>后面接口的参数</code>，即使接口之间存在依赖，也可以轻松 <strong>一键测试~</strong></p>\n<p>格式：</p>\n<pre class=\"prettyprint\"><code>$.{key}.{params|body}.{path}\n</code></pre><p>例如：现有两个接口，分别是“导航标题”和“文章列表”\n<img src=\"https://yapi.ymfe.org/images/usage/case_key_list.png\" alt></p>\n<p>文章列表接口需要传参数: <code>当前标题(id)</code>，而这个 id 需要通过 <code>导航标题</code> 的返回值获取，这时应在 <code>文章列表</code> 的参数输入框中根据前者的 key 找到对应 id。</p>\n<p><code>导航标题</code> 的参数和返回值有如下结构：</p>\n<p>参数：\n<img src=\"https://yapi.ymfe.org/images/usage/case_key_res_query.png\" alt></p>\n<p>返回值：</p>\n<p><img src=\"https://yapi.ymfe.org/images/usage/case_key_res.png\" alt></p>\n<p>则 <code>文章列表</code> 的参数可以如下配置：\n<img src=\"https://yapi.ymfe.org/images/usage/case_key_query.png\" alt></p>\n<p>其中 <strong>$.</strong> 是使用 <strong>动态变量</strong> 的标志，$.269.<strong>params</strong> 即表示 key 值为 269 用例的请求参数，$.269.<strong>body</strong> 即表示 key 值为 269 用例的返回值。</p>\n<blockquote>\n<p>Tips: 上下拖动测试集合的列表项可以调整测试的顺序。</p>\n</blockquote>\n<p>目前yapi中的<code>query</code>，<code>body</code>,<code>header</code>和<code>pathParam</code>的输入参数已经支持点击选择功能。无需自己填写表达式，只需在弹窗中选择需要展示的表达式即可。 输入选项包括<code>常量</code>，<code>mock数据</code>，在测试集合中也支持<code>变量</code>选择。\n具体用法：单击编辑按钮打开表达式生成器，点击需要的数据创建表达式，这里也可以实时查看表达式结果。</p>\n<p><img src=\"https://yapi.ymfe.org/images/usage/modal-postman.gif\" alt></p>\n<h3>第二步：开始测试</h3>\n<p><img src=\"https://yapi.qunar.com/images/usage/case-list.gif\" alt=\"case\"></p>\n<p>在测试列表可以看到每个测试用例的 key,还有 开始测试、报告等功能\n点击开始测试会按照 case 定义的参数从上往下一个一个进行测试，如果顺序有问题，可以拖动调整\n测试完成之后，点击报告查看该次请求的结果</p>\n<h2>后记：</h2>\n<p>YApi 自动化测试大大简化了接口测试数据准备，和验证环节，目前去哪儿测试团队已经开始使用。未来 YApi 将会持续优化自动化测试功能，希望大家提出大家宝贵的意见。</p>\n<p>开源接口管理平台 <a href=\"http://yapi.qunar.com\">YApi 官网</a></p>\n<p>Github: <a href=\"https://github.com/ymfe/yapi\">YApi github</a></p>\n</div>",
            "title": "去哪儿 Api 自动化测试实践",
            "last_reply_at": "2017-12-20T07:32:47.657Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 176,
            "create_at": "2017-12-20T07:32:47.657Z",
            "author": {
                "loginname": "suxiaoxin",
                "avatar_url": "https://avatars0.githubusercontent.com/u/17695103?v=4&s=120"
            }
        },
        {
            "id": "5a33a5b1d92f2f5b185acedd",
            "author_id": "58de5214b3e60b982d089dc3",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>要做爬虫的HTTP代理池, 发现google上搜的免费代理, 基本上都根本用不了, 就是HTTP请求都没法代理.\n付费的HTTP代理里面:\n\t找了个<a href=\"http://www.kuaidaili.com/pricing\">快代理</a>, 用了他们的私密代理, 试了十几个, HTTP请求能够正常代理的, 但貌似代理的ip都在淘宝的爬虫黑名单.\n\t找了淘宝上的, 买了一个ip试了一下, 完全ok, 但是要每个ip 20元/月, 多买些IP太贵了.\n请做过爬虫代理池的大牛分享一下资源哈.</p>\n</div>",
            "title": "爬虫HTTP代理池问题",
            "last_reply_at": "2017-12-20T07:28:31.390Z",
            "good": false,
            "top": false,
            "reply_count": 21,
            "visit_count": 415,
            "create_at": "2017-12-15T10:36:33.513Z",
            "author": {
                "loginname": "XiaozhongLiu",
                "avatar_url": "https://avatars3.githubusercontent.com/u/17674404?v=4&s=120"
            }
        },
        {
            "id": "58ad76db7872ea0864fedfcc",
            "author_id": "51f0f267f4963ade0e08f503",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FlwW5i2h_UuKpnBXXvD3AqyrwjHP\" alt=\"untitled4.png\"></p>\n<h1>饿了么大前端 Node.js 进阶教程</h1>\n<p>因为 2016 年面试了很多做 Node.js 的同学，发现大部分做 Node 的同学都是前端转过来的，对后端的知识大多一片空白。所以很难招到比较好的 Node.js 服务端程序员（注意，不是全栈）。</p>\n<p>于是出于我们一贯的开源与分享精神，我们筹备了这个名字叫《如何通过饿了么 Node.js 面试》的开源的 Node.js 进阶教程。</p>\n<p>github 仓库地址：<a href=\"https://github.com/ElemeFE/node-interview\">https://github.com/ElemeFE/node-interview</a></p>\n<h3>导读</h3>\n<p>本教程包含 2~3 年经验的 Node.js 服务端需要知道的知识点。</p>\n<p>需要注意的是, 并不适用于零基础的同学, 你需要有一定的 JavaScript/Node.js 基础, 并且有一定的工作经验. 另外本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分.</p>\n<p>稳重将一些常见的问题划分归类, 每类标明涵盖的一些<code>覆盖点</code>, 并且列举几个<code>常见问题</code>, 通常这些问题都是 2~3 年工作经验需要了解或者面对的. 如果你对某类问题感兴趣, 或者想知道其中列举问题的答案, 可以通过该类下方的 <code>阅读更多</code> 查看更多的内容.</p>\n<p>整体上大纲列举的并不是很全面, 细节上覆盖率不高, 很多讨论只是点到即止, 希望大家带着问题去思考.</p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md\">Js 基础问题</a></h2>\n<blockquote>\n<p>与前端 Js 不同, 后端是直面服务器的, 更加偏向内存方面.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD\"><code>[Basic]</code> 类型判断</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><code>[Basic]</code> 作用域</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\"><code>[Basic]</code> 引用传递</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE\"><code>[Basic]</code> 内存释放</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#es6-%E6%96%B0%E7%89%B9%E6%80%A7\"><code>[Basic]</code> ES6 新特性</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-value\">[more]</a></li>\n<li>js 中， 0.1 + 0.2 === 0.3 是否为 true ? 在不知道浮点数位数时应该怎样判断两个浮点数之和与第三数是否相等？</li>\n<li>const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-const\">[more]</a></li>\n<li>JavaScript 中不同类型以及不同环境下变量的内存都是何时释放? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-mem\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md\">模块</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6\"><code>[Basic]</code> 模块机制</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E7%83%AD%E6%9B%B4%E6%96%B0\"><code>[Basic]</code> 热更新</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E4%B8%8A%E4%B8%8B%E6%96%87\"><code>[Basic]</code> 上下文</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-loop\">[more]</a></li>\n<li>如果 a.js require 了 b.js, 那么在 b 中定义全局变量 <code>t = 111</code> 能否在 a 中直接打印出来? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-global\">[more]</a></li>\n<li>如何在不重启 node 进程的情况下热更新一个 js/json 文件? 这个问题本身是否有问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-hot\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md\">事件/异步</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#promise\"><code>[Basic]</code> Promise</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#events\"><code>[Doc]</code> Events (事件)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#timers\"><code>[Doc]</code> Timers (定时器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5\"><code>[Point]</code> 阻塞/异步</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91\"><code>[Point]</code> 并行/并发</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Promise 中 .then 的第二参数与 .catch 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-1\">[more]</a></li>\n<li>Eventemitter 的 emit 是同步还是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-2\">[more]</a></li>\n<li>如何判断接口是否异步? 是否只要有回调函数就是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-3\">[more]</a></li>\n<li>nextTick, setTimeout 以及 setImmediate 三者有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-4\">[more]</a></li>\n<li>如何实现一个 sleep 函数? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-5\">[more]</a></li>\n<li>如何实现一个异步的 reduce? (注:不是异步完了之后同步 reduce) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-6\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md\">进程</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#process\"><code>[Doc]</code> Process (进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#child-process\"><code>[Doc]</code> Child Processes (子进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#cluster\"><code>[Doc]</code> Cluster (集群)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><code>[Basic]</code> 进程间通信</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\"><code>[Basic]</code> 守护进程</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>进程的当前工作目录是什么? 有什么作用? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-cwd\">[more]</a></li>\n<li>child_process.fork 与 POSIX 的 fork 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-fork\">[more]</a></li>\n<li>父进程或子进程的死亡是否会影响对方? 什么是孤儿进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-child\">[more]</a></li>\n<li>cluster 是如何保证负载均衡的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#how-it-works\">[more]</a></li>\n<li>什么是守护进程? 如何实现守护进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md\">IO</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#buffer\"><code>[Doc]</code> Buffer</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#string-decoder\"><code>[Doc]</code> String Decoder (字符串解码)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#stream\"><code>[Doc]</code> Stream (流)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#console\"><code>[Doc]</code> Console (控制台)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#file\"><code>[Doc]</code> File System (文件系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#readline\"><code>[Doc]</code> Readline</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#repl\"><code>[Doc]</code> REPL</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Buffer 一般用于处理什么数据? 其长度能否动态变化? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#buffer\">[more]</a></li>\n<li>Stream 的 highWaterMark 与 drain 事件是什么? 二者之间的关系是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#%E7%BC%93%E5%86%B2%E5%8C%BA\">[more]</a></li>\n<li>Stream 的 pipe 的作用是? 在 pipe 的过程中数据是引用传递还是拷贝传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#pipe\">[more]</a></li>\n<li>什么是文件描述符? 输入流/输出流/错误流是什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#file\">[more]</a></li>\n<li>console.log 是同步还是异步? 如何实现一个 console.log? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#console\">[more]</a></li>\n<li>如何同步的获取用户的输入?  <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E7%9A%84%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5\">[more]</a></li>\n<li>Readline 是如何实现的? (有思路即可) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#readline\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md\">Network</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#net\"><code>[Doc]</code> Net (网络)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#udp\"><code>[Doc]</code> UDP/Datagram</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#http\"><code>[Doc]</code> HTTP</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#dns\"><code>[Doc]</code> DNS (域名服务器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#zlib\"><code>[Doc]</code> ZLIB (压缩)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#rpc\"><code>[Point]</code> RPC</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>cookie 与 session 的区别? 服务端如何清除 cookie? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-cookie-session\">[more]</a></li>\n<li>HTTP 协议中的 POST 和 PUT 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-post-put\">[more]</a></li>\n<li>什么是跨域请求? 如何允许跨域? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-cors\">[more]</a></li>\n<li>TCP/UDP 的区别? TCP 粘包是怎么回事，如何处理? UDP 有粘包吗? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-tcp-udp\">[more]</a></li>\n<li><code>TIME_WAIT</code> 是什么情况? 出现过多的 <code>TIME_WAIT</code> 可能是什么原因? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-time-wait\">[more]</a></li>\n<li>ECONNRESET 是什么错误? 如何复现这个错误?</li>\n<li>socket hang up 是什么意思? 可能在什么情况下出现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#socket-hang-up\">[more]</a></li>\n<li>hosts 文件是什么? 什么叫 DNS 本地解析?</li>\n<li>列举几个提高网络传输速度的办法?</li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md\">OS</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#tty\"><code>[Doc]</code> TTY</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#os\"><code>[Doc]</code> OS (操作系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#path\"><code>[Doc]</code> Path</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0\"><code>[Doc]</code> 命令行参数</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E8%B4%9F%E8%BD%BD\"><code>[Basic]</code> 负载</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#checklist\"><code>[Point]</code> CheckList</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>什么是 TTY? 如何判断是否处于 TTY 环境? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#tty\">[more]</a></li>\n<li>不同操作系统的换行符 (EOL) 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#os\">[more]</a></li>\n<li>服务器负载是什么概念? 如何查看负载? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E8%B4%9F%E8%BD%BD\">[more]</a></li>\n<li>ulimit 是用来干什么的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#ulimit\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md\">错误处理/调试/优化</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#errors\"><code>[Doc]</code> Errors (异常)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#domain\"><code>[Doc]</code> Domain (域)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#debugger\"><code>[Doc]</code> Debugger (调试器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#c-c++-addon\"><code>[Doc]</code> C/C++ 插件</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#v8\"><code>[Doc]</code> V8</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\"><code>[Point]</code> 内存快照</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#cpu-profiling\"><code>[Point]</code> CPU profiling</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>怎么处理未预料的出错? 用 try/catch ，domains 还是其它什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#q-handle-error\">[more]</a></li>\n<li>什么是 <code>uncaughtException</code> 事件? 一般在什么情况下使用该事件? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#uncaughtexception\">[more]</a></li>\n<li>domain 的原理是? 为什么要弃用 domain? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#domain\">[more]</a></li>\n<li>什么是防御性编程? 与其相对的 let it crash 又是什么?</li>\n<li>为什么要在 cb 的第一参数传 error? 为什么有的 cb 第一个参数不是 error, 例如 http.createServer?</li>\n<li>为什么有些异常没法根据报错信息定位到代码调用? 如何准确的定位一个异常? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E9%94%99%E8%AF%AF%E6%A0%88%E4%B8%A2%E5%A4%B1\">[more]</a></li>\n<li>内存泄漏通常由哪些原因导致? 如何分析以及定位内存泄漏? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md\">测试</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95\"><code>[Basic]</code> 测试方法</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 单元测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 集成测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 基准测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 压力测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#assert\"><code>[Doc]</code> Assert (断言)</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>为什么要写测试? 写测试是否会拖累开发进度?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#q-why-write-test\">[more]</a></li>\n<li>单元测试的单元是指什么? 什么是覆盖率?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">[more]</a></li>\n<li>测试是如何保证业务逻辑中不会出现死循环的?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#q-death-loop\">[more]</a></li>\n<li>mock 是什么? 一般在什么情况下 mock?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#mock\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md\">util</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#url\"><code>[Doc]</code> URL</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#query-strings\"><code>[Doc]</code> Query Strings (查询字符串)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#util-1\"><code>[Doc]</code> Utilities (实用函数)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><code>[Basic]</code> 正则表达式</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>HTTP 如何通过 GET 方法 (URL) 传递 let arr = [1,2,3,4] 给服务器? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#get-param\">[more]</a></li>\n<li>Node.js 中继承 (util.inherits) 的实现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#utilinherits\">[more]</a></li>\n<li>如何递归获取某个文件夹下所有的文件名? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#q-traversal\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md\">存储</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#mysql\"><code>[Point]</code> Mysql</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#mongodb\"><code>[Point]</code> Mongodb</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#replication\"><code>[Point]</code> Replication</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\"><code>[Point]</code> 数据一致性</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%BC%93%E5%AD%98\"><code>[Point]</code> 缓存</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>备份数据库与 M/S, M/M 等部署方式的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#replication\">[more]</a></li>\n<li>索引有什么用，大致原理是什么? 设计索引有什么注意点? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%B4%A2%E5%BC%95\">[more]</a></li>\n<li>Monogdb 连接问题(超时/断开等)有可能是什么问题导致的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#Mongodb\">[more]</a></li>\n<li>什么情况下数据会出现脏数据? 如何避免? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\">[more]</a></li>\n<li>redis 与 memcached 的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%BC%93%E5%AD%98\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md\">安全</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#crypto\"><code>[Doc]</code> Crypto (加密)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#tlsssl\"><code>[Doc]</code> TLS/SSL</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#https\"><code>[Doc]</code> HTTPS</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\"><code>[Point]</code> XSS</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#csrf\"><code>[Point]</code> CSRF</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\"><code>[Point]</code> 中间人攻击</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#sqlnosql-%E6%B3%A8%E5%85%A5\"><code>[Point]</code> Sql/Nosql 注入</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>加密是如何保证用户密码的安全性? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#crypto\">[more]</a></li>\n<li>TLS 与 SSL 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#tlsssl\">[more]</a></li>\n<li>HTTPS 能否被劫持? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#https\">[more]</a></li>\n<li>XSS 攻击是什么? 有什么危害? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\">[more]</a></li>\n<li>过滤 Html 标签能否防止 XSS? 请列举不能的情况? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\">[more]</a></li>\n<li>CSRF 是什么? 如何防范? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#csrf\">[more]</a></li>\n<li>如何避免中间人攻击? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md\">阅读更多</a></p>\n<h2>最后</h2>\n<p>目前 repo 处于施工现场的情况，如果发现问题欢迎在 <a href=\"https://github.com/ElemeFE/node-interview/issues\">issues</a> 中指出。如果有比较好的<code>问题/知识点/指正</code>，也欢迎提 PR。</p>\n<p>另外关于 <code>Js 基础</code> 是个比较大的话题，在本教程不会很细致深入的讨论，更多的是列出一些重要或者更服务端更相关的地方，所以如果你拿着《JavaScript 权威指南》给教程提 PR 可能不会采纳。本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分。</p>\n</div>",
            "title": "饿了么大前端 Node.js 进阶教程",
            "last_reply_at": "2017-12-20T07:23:18.421Z",
            "good": true,
            "top": false,
            "reply_count": 282,
            "visit_count": 886259,
            "create_at": "2017-02-22T11:32:43.547Z",
            "author": {
                "loginname": "lellansin",
                "avatar_url": "https://avatars2.githubusercontent.com/u/2081487?v=4&s=120"
            }
        },
        {
            "id": "5a391474d92f2f5b185ad022",
            "author_id": "59c1dcee8812ce51127a9026",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>这个框架在 <code>connect</code> 的基础上对 <code>req</code> 和 <code>res</code> 增加了更多的属性的方法，它既有 <code>express</code> 风格，也有 <code>koa</code> 风格，同时支持绝大多数 <code>connect</code> 和 <code>express</code> 所支持的中间价/插件。</p>\n<p>它体积非常小，但功能并不少，<code>koa</code> 有的，它基本都有，<code>express</code> 有的，也大多有，除了路由（当然已经有第三方的 <code>connect</code> 模块对其提供）。</p>\n<p><code>connect</code> 的文档有点缺少并且错误，因此这个框架自己提供了一个 <code>.d.ts</code> 文件，来提供完整的 IDE 支持。</p>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>const { App } = require(&quot;.&#x2F;index&quot;);\nconst http = require(&quot;http&quot;);\n\nvar app = new App();\n\napp.use((req, res) =&gt; {\n\t&#x2F;&#x2F; Print out some request imformation:\n\tconsole.log(&quot;Client IP:&quot;, req.ip);\n\tconsole.log(&quot;Requested href:&quot;, req.href);\n\tconsole.log(&quot;Requested hostname:&quot;, req.hostname);\n\tconsole.log(&quot;Accepted Language:&quot;, req.lang);\n\n\t&#x2F;&#x2F; Set some response information.\n\tres.cookies.username = &quot;Luna&quot;;\n\tres.refresh = 5; &#x2F;&#x2F; refresh the page every 5 seconds.\n\n\tres.send(&quot;&lt;p&gt;Hello, World!&lt;&#x2F;p&gt;&quot;); &#x2F;&#x2F; text&#x2F;html;\n}).listen(80);\n</code></pre><p>在性能上，下面是 JMeter 压力测试的结果：</p>\n<pre class=\"prettyprint\"><code>webium.res.end:\n\t10000 in 00:00:06 = 1721.8&#x2F;s Avg:   292 Min:     1 Max:  2207 Err:   546 (5.46%)\nwebium.res.send:\n\t10000 in 00:00:07 = 1456.9&#x2F;s Avg:   368 Min:     2 Max:  2294 Err:   906 (9.06%)\n\nexpress.res.end:\n\t10000 in 00:00:06 = 1572.8&#x2F;s Avg:   336 Min:     1 Max:  1970 Err:   706 (7.06%)\nexpress.res.send:\n\t10000 in 00:00:07 = 1456.2&#x2F;s Avg:   356 Min:     2 Max:  2187 Err:   841 (8.41%)\n\nkoa.ctx.body:\n\t10000 in 00:00:06 = 1738.2&#x2F;s Avg:   263 Min:     1 Max:  2133 Err:   360 (3.60%)\n\nconnect.res.end:\n\t10000 in 00:00:05 = 2066.1&#x2F;s Avg:   210 Min:     0 Max:  2127 Err:   208 (2.08%)\n</code></pre><p>由于 <strong>webium</strong> 对某些属性进行了预计算，因此在 <code>Hello, World!</code> 这些简单响应中会比 <code>koa</code> 稍差一些，但在更复杂的场景下，它会比每一次使用都重新计算的的 <code>koa</code> 表现要好些。</p>\n<p>同时，<strong>webium</strong> 的 <code>res.send()</code> 放大，提供更多的类型检测，能够自动判断响应的字符串是 HTML 还是 XML, 或者 JSON，并且，沿袭 express 的风格，在处理相同的响应内容时，发送 304 响应，而不是 200。</p>\n<p>GitHub: <a href=\"https://github.com/Hyurl/webium\">https://github.com/Hyurl/webium</a></p>\n</div>",
            "title": "基于 connect 的 web 应用程序框架 webium",
            "last_reply_at": "2017-12-20T06:22:08.508Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 201,
            "create_at": "2017-12-19T13:30:28.376Z",
            "author": {
                "loginname": "Hyurl",
                "avatar_url": "https://avatars1.githubusercontent.com/u/16103955?v=4&s=120"
            }
        },
        {
            "id": "5a3675019807389a1809f485",
            "author_id": "59f5c3b34f3d4bb9772ae35b",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h1>序章</h1>\n<ul>\n<li>之前一直做游戏app客户端，有天老板说app游戏不好混了，我们做H5游戏吧。。。</li>\n<li>用cocos creator做的时候，的确也可以一样画葫芦的做下去，但发现还是学点web基础更有帮助</li>\n<li>开始看书（JavaScript高级程序设计），去百度前端技术学院自学，做实例。在这接触到了nodejs</li>\n<li>那把nodejs也了解下吧，开始看书（深入浅出Node.js），做例子的时候，咦，别人写的方法怎么是=&gt;这样的。。</li>\n<li>了解了下，哦，原来是js的新标准，那也随便了解下吧，开始看书（ECMAScript 6 入门）。。。</li>\n<li>等我了解了es6基本语法后，又冒出koa2, vue等等框架（都是百度前端技术学院例子里涉及到的。。）</li>\n<li>我怕我再看下去要疯了，而且接下去，h5项目要开始赶进度了（就是加班）。之前涉及到的知识点也够撸了。</li>\n<li>这里先总结下koa2框架等相关知识吧。。。</li>\n<li>等之后有空了就撸vue框架。都会基于这个小项目</li>\n</ul>\n<h2>技术支持</h2>\n<ul>\n<li>JavaScript高级程序设计</li>\n<li>深入浅出Node.js</li>\n<li>ECMAScript 6 入门</li>\n</ul>\n<h2>环境准备</h2>\n<ul>\n<li>node: v8.6.0</li>\n<li>MongoDB: 3.4.9</li>\n<li>部署到阿里云的环境\n<ul>\n<li>CPU：1核 内存：1GB</li>\n<li>CentOS 7.4 64位</li>\n</ul>\n</li>\n</ul>\n<h2>地址</h2>\n<ul>\n<li><a href=\"http://101.132.189.125:8000\">测试地址</a></li>\n<li><a href=\"https://github.com/wugui0220/BLOG.git\">GitHub</a></li>\n</ul>\n<h2>框架</h2>\n<pre class=\"prettyprint language-sh\"><code>├── config.js             # 配置文件\n├── public                # 静态资源目录\n│   ├── blogs             # 博客文章目录\n│   ├── images            # 图片资源目录\n│   ├── scripts           # 静态脚本目录\n│   └── styles            # 样式目录\n└── server                # 后端代码目录\n    ├── db                # 数据库目录\n    ├── middlewares       # 自定义中间件目录\n    ├── models            # 数据模型目录\n    ├── routers           # 路由目录\n    ├── services          # 逻辑服务目录\n    ├── utils             # 工具目录\n    ├── views             # 视图目录\n    └── app.js            # 入口文件\n</code></pre><h2>目录</h2>\n<ul>\n<li><a href=\"http://101.132.189.125:8000/blogs/1\">开始</a></li>\n<li><a href=\"http://101.132.189.125:8000/blogs/2\">路由</a></li>\n<li><a href=\"http://101.132.189.125:8000/blogs/3\">模板引擎</a></li>\n<li><a href=\"http://101.132.189.125:8000/blogs/4\">静态资源</a></li>\n<li><a href=\"http://101.132.189.125:8000/blogs/5\">登录框</a></li>\n<li><a href=\"http://101.132.189.125:8000/blogs/6\">数据解析</a></li>\n<li><a href=\"http://101.132.189.125:8000/blogs/7\">数据库</a></li>\n<li><a href=\"http://101.132.189.125:8000/blogs/8\">数据模型</a></li>\n<li><a href=\"http://101.132.189.125:8000/blogs/9\">逻辑服务</a></li>\n<li><a href=\"http://101.132.189.125:8000/blogs/10\">session</a></li>\n<li><a href=\"http://101.132.189.125:8000/blogs/11\">博客内容</a></li>\n<li><a href=\"http://101.132.189.125:8000/blogs/12\">小结</a></li>\n<li><a href=\"http://101.132.189.125:8000/blogs/13\">评论系统</a></li>\n</ul>\n</div>",
            "title": "基于koa2 + mongodb + handlebars 开发博客系统",
            "last_reply_at": "2017-12-20T06:16:23.245Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 627,
            "create_at": "2017-12-17T13:45:37.744Z",
            "author": {
                "loginname": "wugui0220",
                "avatar_url": "https://avatars3.githubusercontent.com/u/6694082?v=4&s=120"
            }
        },
        {
            "id": "5a39fd418230827a182938c2",
            "author_id": "59b0fced1b37e54f6793c3d6",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>要把项目向产品化转变第一步需要怎么做？</p>\n</div>",
            "title": "要把项目向产品化转变第一步需要怎么做？",
            "last_reply_at": "2017-12-20T06:14:54.729Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 168,
            "create_at": "2017-12-20T06:03:45.242Z",
            "author": {
                "loginname": "xulayen",
                "avatar_url": "https://avatars1.githubusercontent.com/u/15044564?v=4&s=120"
            }
        },
        {
            "id": "5a378d29d1536726354b7ebd",
            "author_id": "59bcd46ad7cbefc51196443f",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><strong>用最少的代码实现express</strong></p>\n<p><strong>文章目录</strong></p>\n<p><a href=\"https://github.com/WenNingZhang/rewrite_express/tree/master/1_express\">1_express</a></p>\n<p><a href=\"https://github.com/WenNingZhang/rewrite_express/tree/master/2_express\">2_express</a></p>\n<p><a href=\"https://github.com/WenNingZhang/rewrite_express/tree/master/3_express\">3_express</a></p>\n</div>",
            "title": "用最少代码实现express",
            "last_reply_at": "2017-12-20T05:42:36.450Z",
            "good": false,
            "top": false,
            "reply_count": 7,
            "visit_count": 528,
            "create_at": "2017-12-18T09:40:57.959Z",
            "author": {
                "loginname": "WenNingZhang",
                "avatar_url": "https://avatars1.githubusercontent.com/u/23034399?v=4&s=120"
            }
        },
        {
            "id": "5a39d9cdd92f2f5b185ad042",
            "author_id": "5a31e1a6f15b4f306d2f0320",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FpufkDZitM0H3zDF11X5UmvNmkf2\" alt=\"sssssss.png\">；</p>\n<p>看到egg-readyr启动时默认是 master -&gt; app ,master -&gt; agent master -&gt; parent</p>\n<p>master进程还有parent进程吗，如图所示，message里的sendToParent方法process.send master进程向parent进程发送消息。</p>\n<p>但是在master没看到parent进程如何产生的。请教大佬们<br>\n感激！！</p>\n</div>",
            "title": "请问egg源码中 message里为什么还多出一个parent",
            "last_reply_at": "2017-12-20T05:17:25.770Z",
            "good": false,
            "top": false,
            "reply_count": 5,
            "visit_count": 174,
            "create_at": "2017-12-20T03:32:29.274Z",
            "author": {
                "loginname": "1316346949",
                "avatar_url": "https://avatars1.githubusercontent.com/u/24400797?v=4&s=120"
            }
        },
        {
            "id": "5a38df3dd1536726354b7f16",
            "author_id": "58119813eae2a24f34e67f92",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>想构建一个脚手架，但是用download-git-repo报错：‘git clone’ failed with status 128</p>\n<p>download(‘github地址’, process.cwd(), { clone: true }, function (err) {\nif (err) console.log(err)\n})</p>\n<p>求指点这个包怎么用？我想让脚手架工具的模板是从github上下载的而不是和工具放在一起的！</p>\n</div>",
            "title": "求node包（download-git-repo）的使用方法！",
            "last_reply_at": "2017-12-20T05:15:02.289Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 205,
            "create_at": "2017-12-19T09:43:25.631Z",
            "author": {
                "loginname": "chaoming007",
                "avatar_url": "https://avatars3.githubusercontent.com/u/3992432?v=4&s=120"
            }
        },
        {
            "id": "554c8b1cba6070b06ac28e58",
            "author_id": "553890a7b9b9d0b34b7c4063",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>将Function * 保存起来</p>\n<blockquote>\n<pre class=\"prettyprint\"><code>\tFunction *cb = *Handle&lt;Function&gt;::Cast(args[1]);\n\tvoid *callback_data = (void *)(cb);\n\tinfo.callback_data_ = (unsigned char *)callback_data;\n\tinfo.callback_data_len_ = sizeof(callback_data);\n</code></pre></blockquote>\n<p>回调获取Function * ，然后调用</p>\n<blockquote>\n<pre class=\"prettyprint\"><code>\tFunction *cb = (Function *)result_info-&gt;callback_data_;\n\tLocal&lt;Value&gt; argv[] = {\n\t\t*Undefined(),\n\t};\n\tconst unsigned argc = sizeof(argv) &#x2F; sizeof(argv[0]);\n\tassert(cb != NULL);\n\tcb-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);\n\tscope.Close(Undefined());\n</code></pre></blockquote>\n<p>成功执行了一部分回调之后，crash了</p>\n<blockquote>\n<p>PID 2008 received SIGSEGV for address: 0xb\n/vagrant/tx_1.0.9_tss_sdk/game-server/node_modules/segfault-handler/build/Release/segfault-handler.node(+0xfce)[0x7fc1e29bdfce]\n/lib/x86_64-linux-gnu/libpthread.so.0(+0xfcb0)[0x7fc1e2f8ecb0]\nnode(_ZN2v88internal9Execution4CallENS0_6HandleINS0_6ObjectEEES4_iPS4_Pbb+0x114)[0x73cd14]\nnode(_ZN2v88Function4CallENS_6HandleINS_6ObjectEEEiPNS1_INS_5ValueEEE+0x110)[0x6de340]\n/vagrant/tx_1.0.9_tss_sdk/game-server/app/addon/tss/build/Debug/tss.node(_Z34on_chat_judge_result_callback_procPK30TssSdkUicChatJudgeResultInfoV2+0x1d6)[0x7fc1e27b67f3]\n./lib/libtss_sdk.so(_ZN12tss_sdk_impl20plugin_callback_procEPv+0x7a)[0x7fc1e22a289a]\n./lib/libtss_sdk.so(_ZN12tss_sdk_impl19UicUserInputInfoMgr17expire_user_inputEv+0x184)[0x7fc1e22bd074]\n./lib/libtss_sdk.so(_ZN12tss_sdk_impl15TssSdkUicPlugin4procEPv+0xe0)[0x7fc1e22ba550]\n./lib/libtss_sdk.so(_ZN12tss_sdk_impl15TssSdkFramework4procEv+0x426)[0x7fc1e22a9376]\n/vagrant/tx_1.0.9_tss_sdk/game-server/app/addon/tss/build/Debug/tss.node(_ZN10TSSWrapper4ProcERKN2v89ArgumentsE+0x58)[0x7fc1e27b816c]\n[0x32d051ba2a57]\n[1]    2008 abort (core dumped)  node test</p>\n</blockquote>\n<p>目前排除了多线程的问题，所有的回调都是在主线程中被调用的。</p>\n</div>",
            "title": "node addon回调引发的crash",
            "last_reply_at": "2017-12-20T04:20:47.641Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 1175,
            "create_at": "2015-05-08T10:08:28.046Z",
            "author": {
                "loginname": "pipi32167",
                "avatar_url": "https://avatars2.githubusercontent.com/u/1400806?v=4&s=120"
            }
        },
        {
            "id": "567cd9a15451a28007f82ef0",
            "author_id": "5629da22e6a3804c58159198",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><ul>\n<li>slc loopback 初始化项目</li>\n<li>slc loopback:datasource</li>\n<li>slc loopback:model</li>\n</ul>\n<p>Define model relations</p>\n<ul>\n<li>slc loopback:relation</li>\n</ul>\n<p>然后就可以在model.js中写你的实现逻辑了;</p>\n<ul>\n<li>当你已经完成以上,系统就帮你生成了model 对应的所有restful API,</li>\n</ul>\n<p>这时候,你会问,怎么加自定义请求呢?</p>\n<blockquote>\n<p>’ City.remoteMethod(‘getCity’, {\n//isStatic: false,  这是代表不是实例方法,如果是实例方法则为true\naccepts: [\n{arg: ‘cityname’, type: ‘string’}\n],\nreturns: [\n{arg: ‘city’, type: ‘object’}</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>    ],\n\n    http: {path: &#x27;&#x2F;getCity&#x27;, verb: &#x27;get&#x27;}    });&#x27;\n\t&#x27; City.getCity = function getCity(cityname, cb) {}&#x27;  这个是定义的方法;\n\n这样你的自定义方法就搞定了.\n\n\b loopback 交流群:575600225</code></pre></div>",
            "title": "loopback 使用系列之一",
            "last_reply_at": "2017-12-20T04:06:51.552Z",
            "good": false,
            "top": false,
            "reply_count": 16,
            "visit_count": 2959,
            "create_at": "2015-12-25T05:52:33.843Z",
            "author": {
                "loginname": "qxl1231",
                "avatar_url": "https://avatars1.githubusercontent.com/u/8305742?v=4&s=120"
            }
        },
        {
            "id": "5a38e907d92f2f5b185ad018",
            "author_id": "5a31e1a6f15b4f306d2f0320",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>需求是这样的，前端传过来动态代码，我要使用子进程运行，过滤错误，有错误提示前端，代码格式错误。\n全部正确，保存到数据库。虽然这个寻求很不可思议，但是产品就这样要求的。</p>\n<p>运行动态js代码也是nodejs代码，用来请求另一台服务器。我现在的模式是将js动态代码写成js文件\n在child_process…execFile开启子进程去运行它，判断是否错误。</p>\n<p>请问大佬们child_process.spawn怎么直接运行js动态代码，而不用文件形式</p>\n<p>感激</p>\n</div>",
            "title": "请问大佬们child_process.spawn怎么运行动态js代码",
            "last_reply_at": "2017-12-20T03:36:20.224Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 182,
            "create_at": "2017-12-19T10:25:11.035Z",
            "author": {
                "loginname": "1316346949",
                "avatar_url": "https://avatars1.githubusercontent.com/u/24400797?v=4&s=120"
            }
        },
        {
            "id": "59ffbd235eebf62d4d86fc8c",
            "author_id": "563ab85b7320b237394c5a5b",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><a href=\"https://nodejs.org/dist/latest-v9.x/docs/api/timers.html\">Timers</a> 模块应该是 Node.js 最重要的模块之一了。为什么这么说呢？</p>\n<p>在 Node.js 基础库中，任何一个 TCP I/O 都会产生一个 timer（计时器）对象，以便记录请求/响应是否超时。例如，HTTP请求经常会附带 <code>Connection:keep-alive</code> 这个请求头，以让服务器维持 TCP 连接，但这个连接显然不可能一直保持着，所以会为它设置一个超时时间，这在内部库里正是通过 Timers 实现的。</p>\n<p>所以可以肯定地说，<strong>任何使用 Node.js 编写的 Web 服务，一定在底层涉及到了 Timers 模块。（之后我们可以看到，Timers 模块的性能对于 Web 服务而言极其重要</strong>）</p>\n<p>另外，你的 Node.js 代码中也许会调用到诸如 <code>setTimeout</code>、<code>setInternal</code>、<code>setImmediate</code> ，这些方法在浏览器内一般是由浏览器内部实现，而 Node.js 中，这些方法都是由 Timers 模块提供的：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 浏览器中：\n&gt; setTimeout\n&#x2F;&#x2F;=&gt; ƒ setTimeout() { [native code] }\n\n&#x2F;&#x2F; Node.js:\n&gt; setTimeout\n&#x2F;&#x2F;=&gt; { [Function: setTimeout] [Symbol(util.promisify.custom)]: [Function] }\n</code></pre><p>Timers 模块如此重要，所以了解它的运行机制和实现原理对我们深刻理解 Node.js 十分有帮助，那么就开始吧。</p>\n<hr>\n<h1>一、定时器的实现</h1>\n<p>刚才已经提到，在 Node.js 里，<code>setTimeout</code>、<code>setInternal</code>、<code>setImmediate</code> 这些定时器相关的函数是由基础库实现的，那么它们到底是怎么实现的呢？</p>\n<p>Node.js 底层通过 C++ 在 libuv 的基础上包裹了一个 <code>timer_wrap</code> 模块，这个模块提供了 <code>Timer</code> 对象，实现了在 runtime 层面的定时功能。</p>\n<p>简单的说，你可以通过这个 <code>Timer</code> 对象实现一个你自己的 <code>setTimeout</code>：</p>\n<pre class=\"prettyprint language-js\"><code>const Timer = process.binding(&#x27;timer_wrap&#x27;).Timer;\nconst kOnTimeout = Timer.kOnTimeout | 0;\n\nfunction setTimeout(fn, ms) {\n    var timer  = new Timer();  &#x2F;&#x2F; 创建一个 Timer 对象\n    timer.start(ms, 0);        &#x2F;&#x2F; 设置触发时间\n    timer[kOnTimeout] = fn;    &#x2F;&#x2F; 设置回调函数\n    return timer;              &#x2F;&#x2F; 返回定时器\n}\n\n\n&#x2F;&#x2F; 试一试\nsetTimeout(() =&gt; console.log(&#x27;timeout!&#x27;), 1000);\n</code></pre><p>当然，这个 <code>setTimeout</code> 方法不能真正地使用在生产环境中，因为它存在一个很严重的性能问题：</p>\n<p><strong>每次调用该方法，都会创建一个全新的 <code>Timer</code> 对象。</strong></p>\n<p>设想一下，服务器每一秒都会面对成千上万的 TCP 或 HTTP 请求，为每个请求都独立地创建一个 <code>Timer</code> 对象，这里的性能开销对于追求高并发的服务器端程序来说，是不可接受的。</p>\n<p>所以我们需要一种更合理的数据结构来处理大量的 Timer 对象，Node.js 内部非常巧妙地使用了双向链表来解决这个问题。</p>\n<hr>\n<h1>二、名词声明</h1>\n<p>下面的文章中，<strong>我会使用 <code>timer</code> 表示 Node.js 层面的定时器对象</strong>，例如 <code>setTimeout</code>、<code>setInterval</code> 返回的对象：</p>\n<pre class=\"prettyprint language-js\"><code>var timer = setTimeout(() =&gt; {}, 1000);\n</code></pre><p><strong>大写字母开头的 <code>Timer</code> 表示由底层 C++ <code>time_wrap</code> 模块提供的 runtime 层面的定时器对象</strong>：</p>\n<pre class=\"prettyprint language-js\"><code>const Timer = process.binding(&#x27;timer_wrap&#x27;).Timer;\n</code></pre><hr>\n<h1>三、Node.js 的定时器双向链表</h1>\n<p>Node.js 会使用一个双向链表来保存所有<strong>定时时间相同</strong>的 <code>timer</code>，对于同一个链表中的所有 <code>timer</code>，只会创建一个 <code>Timer</code> 对象。当链表中前面的 <code>timer</code> 超时的时候，会触发回调，在回调中重新计算下一次超时的时间，然后重置 <code>Timer</code> 对象，以减少重复 <code>Timer</code> 对象的创建开销。</p>\n<p>上面这两句话信息量比较大，第一次看不懂没关系，接着往下看。</p>\n<p>举个例子，所有 <code>setTimeout(func, 1000)</code> 的定时器都会放置在同一个链表中，共用同一个 <code>Timer</code> 对象。下面我们来看 Node.js 是怎么做到的。</p>\n<h3>3.1、链表的创建</h3>\n<p>在程序执行最初，Timers 模块会初始化两个对象，用于保存链表的头部（看源码请点<a href=\"https://github.com/nodejs/node/blob/1f045f491a6a8d6ac193474f3856e2bdbd6847be/lib/timers.js#L137\">这里</a>）：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; - key = time in milliseconds\n&#x2F;&#x2F; - value = linked list\nconst refedLists = Object.create(null);\nconst unrefedLists = Object.create(null);\n</code></pre><p><strong>我们在后文中称这两个对象为 <code>lists</code> 对象</strong>，它们的区别在于， <code>refedLists</code> 是给 Node.js 外部的定时器（即第三方代码）使用的，而 <code>unrefedLists</code> 是给内部模块（如 <code>net</code>、<code>http</code>、<code>http2</code>）使用。</p>\n<p>相同之处在于，它们的 key 代表这一组定时器的超时时间，key 对应的 value，都是一个定时器链表。例如 <code>lists[1000]</code> 对应的就是由一个或多个超时时间为 <code>1000ms</code> 的 <code>timer</code> 组成的链表。</p>\n<p>当你的代码中第一次调用定时器方法时，例如：</p>\n<pre class=\"prettyprint language-js\"><code>var timer1 = setTimeout(() =&gt; {}, 1000);\n</code></pre><p>这个时候，<code>lists</code> 对象中当然是空的，没有任何链表，Timers 便会在对应的位置上（这个例子中是<code>lists[1000]</code>）创建一个 <code>TimersList</code> 作为链表的头部，并且把刚才创建的新的 <code>timer</code> 放入链表中（源码请点<a href=\"https://github.com/nodejs/node/blob/1f045f491a6a8d6ac193474f3856e2bdbd6847be/lib/timers.js#L159\">这里</a>）：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; Timers 模块部分源码：\nconst L = require(&#x27;internal&#x2F;linkedlist&#x27;);\nconst lists = unrefed === true ? unrefedLists : refedLists;\n\n&#x2F;&#x2F; 如果已经有链表了，那么直接复用，没有的话就创建一个\nvar list = lists[msecs];\nif (!list) {\n    lists[msecs] = list = createTimersList(msecs, unrefed);\n}\n\n&#x2F;&#x2F; 略过一些初始化步骤......\n\n&#x2F;&#x2F; 把 timer 加入链表\nL.append(list, timer);\n</code></pre><p>你可以亲自试一试：</p>\n<pre class=\"prettyprint language-js\"><code>var timer1 = setTimeout(() =&gt; {}, 1000)\n\ntimer1._idlePrev &#x2F;&#x2F;=&gt; TimersList { ...... }\ntimer1._idlePrev._idleNext &#x2F;&#x2F;=&gt; timer1\n</code></pre><p>正如我们之前说到的，上面 <code>setTimeout(() =&gt; {}, 1000)</code> 这个定时器，会保存在 <code>lists[1000]</code> 这个链表中。</p>\n<p>这个时候，我们链表的状态是这样的：\n<img src=\"https://user-gold-cdn.xitu.io/2017/11/5/52539af720d0aebc16cac40ce07a9d86\" alt></p>\n<h3>3.2、向链表中添加节点</h3>\n<p>假设我们一段时间后又添加了一个新的、相同时间的 timer：</p>\n<pre class=\"prettyprint language-js\"><code>var timer2 = setTimeout(() =&gt; {}, 1000);\n</code></pre><p>这个新的 <code>timer2</code> 会被加入到链表中， 和之前的 <code>timer1</code> 在同一个链表中：</p>\n<pre class=\"prettyprint language-js\"><code>timer1._idlePrev === timer2 &#x2F;&#x2F; true\ntimer2._idleNext === timer1 &#x2F;&#x2F; true\n</code></pre><p>如果画成图的话就是类似这样：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2017/11/5/b6114d7b10f62eb4c87e833177e8d039\" alt></p>\n<p><em>（PS：我们一直提到的这个双向链表，其实是是独立于 Timers 模块实现的，你可以在这里看到它的具体实现代码：<a href=\"https://github.com/nodejs/node/blob/master/lib/internal/linkedlist.js\">linkedlist.js</a>）</em></p>\n<p>用一张图来总结一下就是，Timers 模块是这样储存 timer的：\n<img src=\"https://user-gold-cdn.xitu.io/2017/11/5/31f726e1a3c13cf58814ccb61d212470\" alt></p>\n<p>现在你已经知道了如何用双向链表保存 timer，接下来我们看看 Node.js 是如何利用双向链表实现 <code>Timer</code> 对象复用的吧。</p>\n<h3>3.3、使用双向链表复用 Timer 对象</h3>\n<p>虽然我们把定时时间相同的 <code>timer</code> 放到了一起，但由于它们的添加时间不一样，所以它们的执行时间也不一样。</p>\n<p>例如，链表中的第 1 个 <code>timer</code> 是在程序最初设置的，而第 2 个 <code>timer</code> 是在稍后时间设置的，它们定时时间相同，所以位于同一链表中，但由于时间先后顺序，当然不可能同时触发。</p>\n<p>在链表中，<strong>Node.js 使用 <code>_idleStart</code> 来记录 <code>timer</code> 设置定时的时间</strong>，或者理解为 <code>timer</code> 开始计时的时间。</p>\n<pre class=\"prettyprint language-js\"><code>var timer1 = setTimeout(() =&gt; {}, 100 * 1000) &#x2F;&#x2F; 这里我们把时间设长一些，防止定时器超时后被从链表中删除\ntimer1._idleStart &#x2F;&#x2F;=&gt; 10829\n\n&#x2F;&#x2F; 一段时间后（100秒之内），设置第二个定时器 =￣ω￣=\nvar timer2 = setTimeout(() =&gt; {}, 100 * 1000)\ntimer2._idleStart &#x2F;&#x2F;=&gt; 23333\n\n&#x2F;&#x2F; 此时它们依然在同一个链表中：\ntimer1._idlePrev === timer2 &#x2F;&#x2F; true\ntimer2._idleNext === timer1 &#x2F;&#x2F; true\n</code></pre><p>画成图的话就是这样：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2017/11/5/1e01b8ab6f810d2cb67630f862f082da\" alt></p>\n<p>你可能会很奇怪，为什么我们的链表中最左侧这个奇怪的 <code>TimersList</code> 到底是个啥？难道只是一个头部装饰品吗？</p>\n<p>事实上，<code>TimersList</code> 就包含着我们所要复用的 <code>Timer</code> 对象，也就是底层 C++ 实现的那个定时器，它承担了整个链表的计时工作。</p>\n<p>等时间到 100 秒时，<code>timer1</code> 该触发了，这个时候会发生一些系列事情：</p>\n<ol>\n<li>承担计时任务的 <code>TimersList</code> 对象中的 <code>Timer</code> （也就是 C++ 实现的那个东西）触发回调，执行 <code>timer1</code> 所绑定的回调函数；</li>\n<li>把 <code>timer1</code> 从链表中移除；</li>\n<li>重新计算多久后触发下一次回调（即 <code>timer2</code> 对应的回调），重置 <code>Timer</code>，重复 1 过程。</li>\n</ol>\n<p>下面用图来描绘一下整个过程：</p>\n<p>首先，在两个定时器添加之后：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2017/11/5/69bc6bef8a4da3f27060a173ba44a669\" alt></p>\n<p>100秒到了，此时 <code>Timer</code> 对象触发，执行 <code>timer1</code> 对应的回调函数：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2017/11/5/993f138e668ff2de171bd10d8afed0fa\" alt></p>\n<p>然后 <code>timer1</code> 被移除出链表，重新计算下次触发时间，重设 <code>Timer</code>，此时状态变为：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2017/11/5/617483bd7f62d7732085fd5a0385e90d\" alt></p>\n<p>整个过程的源码请参考<a href=\"https://github.com/nodejs/node/blob/9f3d59eabb6564ad337a762d61ac767f9130e8a5/lib/timers.js#L212\">这里</a></p>\n<p><strong>这样，我们便通过一个双向链表实现了 <code>Timer</code> 对象的复用，一个链表只需要一个 <code>Timer</code>，大大提高了 Timers 模块的性能。</strong></p>\n<hr>\n<h1>四、为什么要这样设计？</h1>\n<p>看到这里你可能会觉得，上面提到的这些设计，都很理所当然，天经地义。</p>\n<p>然而并非如此，对于处理多个 <code>timer</code> 对象，熟悉算法的同学肯定能想到，<strong>我们完全可以只用一个 <code>Timer</code>！</strong></p>\n<p>例如，我们可以把所有 <code>timer</code> 都放在唯一一个链表中，每次创建 <code>timer</code> 时，都通过计算 <code>timer</code> 具体执行的时间，从而找到合适的位置，把新的 <code>timer</code> 插入到链表中：</p>\n<p>比如，最初的链表是这样：</p>\n<pre class=\"prettyprint\"><code>TimersList &lt;-----&gt; timer1 &lt;-----&gt; timer2 &lt;-----&gt; timer3 &lt;-----&gt; ......\n                1000ms后执行     1050ms后执行      1200ms后执行\n</code></pre><p>此时我们调用</p>\n<pre class=\"prettyprint language-js\"><code>var timer4 = setTimeout(() =&gt; {}, 1100);\n</code></pre><p><code>timer4</code> 应该插入到哪儿呢？一个线性查找便可以找到位置，即在 <code>timer2</code> 和 <code>timer3</code> 之间：</p>\n<pre class=\"prettyprint\"><code>                                                  插入！\nTimersList &lt;-----&gt; timer1 &lt;-----&gt; timer2 &lt;-----&gt; timer4 &lt;-----&gt; timer3 &lt;-----&gt; ......\n                1000ms后执行     1050ms后执行    1100ms后执行    1200ms后执行\n</code></pre><p>熟悉算法的同学看到<strong>线性查找</strong>肯定立刻意识到了，完全可以用一个<code>O(lgn)</code>的<strong>二叉树</strong>代替上面这个需要线性查找<code>O(n)</code>的链表。</p>\n<p><strong>这样我们不但可以只用一个 <code>Timer</code> 对象，而且可以用最佳的效率找到 <code>timer</code> 的插入位置</strong>，为什么 Node.js 都 v9.0 了还没有使用这样的算法呢？</p>\n<p>事实上，社区很早之前就已经尝试过<strong>二叉树</strong>或者<strong>时间片轮转调度</strong>算法，但这些算法实际的性能数据却不如上文提到的<strong>多链表</strong>实现，为什么呢？</p>\n<p>因为内部库里，如 <code>net</code>、<code>http</code> 模块，为 <code>timer</code> 设定的超时时间基本是固定的，所以产生了一个经验性的假设：<strong>越晚创建的 <code>timer</code> 很可能越晚执行</strong>。</p>\n<p>基于这个假设我们再来看二叉树算法，由于假设的存在，每次插入新的 <code>timer</code>，由于插入时间最晚，执行时间极可能也是最晚的，所以很容易进入树的最右侧，此时，我们的二叉树便退化成了一个普通的链表。性能优势也不复存在。（平衡二叉树？那就更不可能了）</p>\n<hr>\n<h1>五、后谈</h1>\n<p>其实，Timers 模块的设计并非一簇而就，它的历史也是十分有趣。早在 Node.js v0.x 的史前时代，之前提到的 <code>refedLists</code> 和 <code>unrefedLists</code> 这两个对象是分开实现的：对于第三方代码，使用的是多链表的结构；对于内部库，使用的是单一链表的结构。</p>\n<p>你可以在<a href=\"https://github.com/nodejs/node/blob/5abd4ac079b390467360d671a186a061b5aba736/lib/timers.js#L524\">这里</a>看到当年是如何实现链表的线性查找插入的。</p>\n<p>后来直到 2015 年的这个 PR 的提交才正式告别了之前的线性搜索：<a href=\"https://github.com/nodejs/node/pull/2540\">use unsorted array in Timers._unrefActive() #2540</a></p>\n<p>现在，社区里又有人产生了新的关于优化 Timers 的想法：</p>\n<p><a href=\"https://github.com/nodejs/node/issues/16105\">Optimizing ‘unreferenced’ timers #16105</a></p>\n<p>读懂了文章的你，有兴趣吗？</p>\n<h1>六、参考</h1>\n<p>1、<a href=\"https://nodejs.org/en/docs/guides/timers-in-node/\">Timers in Node.js</a></p>\n<p>2、<a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\">The Node.js Event Loop, Timers, and process.nextTick()</a></p>\n<p>3、<a href=\"http://www.cnblogs.com/hust/p/4809208.html\">Node.js timer的优化故事 - 淘小杰</a></p>\n<p>4、<a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\">JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志</a></p>\n</div>",
            "title": "Node.js 核心模块 Timers 详解",
            "last_reply_at": "2017-12-20T03:31:53.478Z",
            "good": false,
            "top": false,
            "reply_count": 7,
            "visit_count": 752,
            "create_at": "2017-11-06T01:38:43.380Z",
            "author": {
                "loginname": "starkwang",
                "avatar_url": "https://avatars0.githubusercontent.com/u/10933333?v=4&s=120"
            }
        }
    ]
}